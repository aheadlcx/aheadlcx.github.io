<!doctype html>
<html class="theme-next   use-motion ">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
    <link href='//fonts.lug.ustc.edu.cn/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />













<meta name="description" content="参考文章

Android 嵌套滑动机制（NestedScrolling）

前言传统的 Android 的 Touch 事件分发机制，主要涉及到下面3个方法  

dispatchTouchEvent
onInterceptTouchEvent
onTouchEvent

其中后面2个方法，是在第一个方法 dispatchTouchEvent 中调用的。在这个涉及里面下，如果父 View把 to">
<meta property="og:type" content="article">
<meta property="og:title" content="NestedScrolling 流程理解">
<meta property="og:url" content="http://www.aheadlcx.xyz/2016/06/13/NestedScrolling-流程理解/index.html">
<meta property="og:site_name" content="believe yourself">
<meta property="og:description" content="参考文章

Android 嵌套滑动机制（NestedScrolling）

前言传统的 Android 的 Touch 事件分发机制，主要涉及到下面3个方法  

dispatchTouchEvent
onInterceptTouchEvent
onTouchEvent

其中后面2个方法，是在第一个方法 dispatchTouchEvent 中调用的。在这个涉及里面下，如果父 View把 to">
<meta property="og:image" content="https://raw.githubusercontent.com/aheadlcx/myPhotos/master/NestedScroll/NestedScrollingChild.png">
<meta property="og:image" content="https://raw.githubusercontent.com/aheadlcx/myPhotos/master/NestedScroll/NestedScrollingChildHelper.png">
<meta property="og:image" content="https://raw.githubusercontent.com/aheadlcx/myPhotos/master/NestedScroll/NestedScrollingParent.png">
<meta property="og:image" content="https://raw.githubusercontent.com/aheadlcx/myPhotos/master/NestedScroll/NestedScrollingParentHelper.png">
<meta property="og:image" content="https://raw.githubusercontent.com/aheadlcx/myPhotos/master/NestedScroll/NestedScroll_Processon.png">
<meta property="og:updated_time" content="2016-09-28T08:41:34.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="NestedScrolling 流程理解">
<meta name="twitter:description" content="参考文章

Android 嵌套滑动机制（NestedScrolling）

前言传统的 Android 的 Touch 事件分发机制，主要涉及到下面3个方法  

dispatchTouchEvent
onInterceptTouchEvent
onTouchEvent

其中后面2个方法，是在第一个方法 dispatchTouchEvent 中调用的。在这个涉及里面下，如果父 View把 to">



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post',
    motion: true
  };
</script>

  <title> NestedScrolling 流程理解 | believe yourself </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">believe yourself</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                NestedScrolling 流程理解
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-06-13T15:57:52+08:00" content="2016-06-13">
              2016-06-13
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/13/NestedScrolling-流程理解/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/13/NestedScrolling-流程理解/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><p>参考文章</p>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000002873657" target="_blank" rel="external">Android 嵌套滑动机制（NestedScrolling）</a></p>
</blockquote>
<h1 id="前言">前言</h1><p>传统的 Android 的 Touch 事件分发机制，主要涉及到下面3个方法  </p>
<ol>
<li>dispatchTouchEvent</li>
<li>onInterceptTouchEvent</li>
<li>onTouchEvent</li>
</ol>
<p>其中后面2个方法，是在第一个方法 dispatchTouchEvent 中调用的。在这个涉及里面下，如果父 View<br>把 touch 事件传递给子 View ，并且子 View 消费了这个事件，那么父 View 就再也不能获得这个<br>touch 事件了。（其实这不是绝对的，只是传统的 Android Touch 事件传递设计初衷就这样，<br>子 View 的 Touch 事件也是经过父 View 的 dispatchTouchEvent 方法的嘛），这种设计，只是<br>不能让父 View 和子 View ，经过交流，来回的传递 Touch 事件。  </p>
<p>在 design 中出现了新的设计实现，还可以兼容旧版本，就是 NestedScrolling 了，<br>就是嵌套滚动的意思 。这套设计的实现，主要涉及到下面几个接口（类）  </p>
<ol>
<li>NestedScrollingChild</li>
<li>NestedScrollingChildHelper</li>
<li>NestedScrollingParent</li>
<li>NestedScrollingParentHelper</li>
</ol>
<h1 id="类简介">类简介</h1><h2 id="NestedScrollingChild">NestedScrollingChild</h2><p><img src="https://raw.githubusercontent.com/aheadlcx/myPhotos/master/NestedScroll/NestedScrollingChild.png" alt=""><br>如果想要配合 ViewGroup 实现嵌套滚动， View 或者 View 的子类就得实现接口<br>NestedScrollingChild .并且需要创建一个 final 的 NestedScrollingChildHelper 作为<br>成员变量，并且将相同点方法签名，都交给 NestedScrollingChildHelper 来代理。</p>
<h2 id="NestedScrollingChildHelper">NestedScrollingChildHelper</h2><p><img src="https://raw.githubusercontent.com/aheadlcx/myPhotos/master/NestedScroll/NestedScrollingChildHelper.png" alt=""><br>这是一个帮助工具类，来实现嵌套滚动的，兼容5.0以前的版本。<br>View 的子类应该创建一个 NestedScrollingChildHelper final 实例，并且把 View 和<br>NestedScrollingChildHelper ，方法签名相同的方法，都委托给  NestedScrollingChildHelper<br>来处理。</p>
<h2 id="NestedScrollingParent">NestedScrollingParent</h2><p><img src="https://raw.githubusercontent.com/aheadlcx/myPhotos/master/NestedScroll/NestedScrollingParent.png" alt=""><br>ViewGroup 的子类应该实现的接口，并且需要创建一个 final 的成员变量<br>NestedScrollingParentHelper ，和 NestedScrollingChild 类似。</p>
<h2 id="NestedScrollingParentHelper">NestedScrollingParentHelper</h2><p><img src="https://raw.githubusercontent.com/aheadlcx/myPhotos/master/NestedScroll/NestedScrollingParentHelper.png" alt=""><br>作用和 NestedScrollingChildHelper 类似。</p>
<h1 id="嵌套滚动原理">嵌套滚动原理</h1><p>我们知道新版本的 RecycleView 是支持嵌套滚动的，所以我们直接抓源码看就好了。<br>我们用 RecycleView 作为 NestedScrollingChild ， CoordinatorLayout 作为<br>NestedScrollingParent 来做例子分析。在这个例子中，整个嵌套 touch 事件分发的流程图如下  </p>
<p><img src="https://raw.githubusercontent.com/aheadlcx/myPhotos/master/NestedScroll/NestedScroll_Processon.png" alt=""></p>
<p>整个流程涉及到的类比较多，而且逻辑也比较复杂。总体而言，需要一个 CoordinatorLayout 直接<br>包裹住所有直接子 View （这也不是绝对的，不过这就是人家的设计，如果需要，当然可以重新自定义<br>一个类似于 CoordinatorLayout 的 ViewGroup 了）。如果直接子 View 的 Behavior  没有拦截<br>touch 事件的话，那么嵌套事件就是从子 View 开始发起的。这里先分开3部分来看，分别从 DOWN ，<br>MOVE 和 UP 事件来看。</p>
<h2 id="嵌套中的_DWON_事件">嵌套中的 DWON 事件</h2><h3 id="起始于_RecycleView_中的_onTouchEvent">起始于 RecycleView 中的 onTouchEvent</h3><p>直接上代码 (精简版)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> canScrollHorizontally = mLayout.canScrollHorizontally();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> canScrollVertically = mLayout.canScrollVertically();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> eventAddedToVelocityTracker = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> MotionEvent vtev = MotionEvent.obtain(e);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(e);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = MotionEventCompat.getActionIndex(e);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> nestedScrollAxis = ViewCompat.SCROLL_AXIS_NONE;</span><br><span class="line">                <span class="keyword">if</span> (canScrollHorizontally) &#123;</span><br><span class="line">                    nestedScrollAxis |= ViewCompat.SCROLL_AXIS_HORIZONTAL;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (canScrollVertically) &#123;</span><br><span class="line">                    nestedScrollAxis |= ViewCompat.SCROLL_AXIS_VERTICAL;</span><br><span class="line">                &#125;</span><br><span class="line">                startNestedScroll(nestedScrollAxis);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> x = (<span class="keyword">int</span>) (MotionEventCompat.getX(e, index) + <span class="number">0.5f</span>);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> y = (<span class="keyword">int</span>) (MotionEventCompat.getY(e, index) + <span class="number">0.5f</span>);</span><br><span class="line">                <span class="keyword">int</span> dx = mLastTouchX - x;</span><br><span class="line">                <span class="keyword">int</span> dy = mLastTouchY - y;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dispatchNestedPreScroll(dx, dy, mScrollConsumed, mScrollOffset)) &#123;</span><br><span class="line">                    dx -= mScrollConsumed[<span class="number">0</span>];</span><br><span class="line">                    dy -= mScrollConsumed[<span class="number">1</span>];</span><br><span class="line">                    vtev.offsetLocation(mScrollOffset[<span class="number">0</span>], mScrollOffset[<span class="number">1</span>]);</span><br><span class="line">                    <span class="comment">// Updated the nested offsets</span></span><br><span class="line">                    mNestedOffsets[<span class="number">0</span>] += mScrollOffset[<span class="number">0</span>];</span><br><span class="line">                    mNestedOffsets[<span class="number">1</span>] += mScrollOffset[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mScrollState != SCROLL_STATE_DRAGGING) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> startScroll = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (canScrollHorizontally &amp;&amp; Math.abs(dx) &gt; mTouchSlop) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (dx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            dx -= mTouchSlop;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            dx += mTouchSlop;</span><br><span class="line">                        &#125;</span><br><span class="line">                        startScroll = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (canScrollVertically &amp;&amp; Math.abs(dy) &gt; mTouchSlop) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (dy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            dy -= mTouchSlop;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            dy += mTouchSlop;</span><br><span class="line">                        &#125;</span><br><span class="line">                        startScroll = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (startScroll) &#123;</span><br><span class="line">                        setScrollState(SCROLL_STATE_DRAGGING);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mScrollState == SCROLL_STATE_DRAGGING) &#123;</span><br><span class="line">                    mLastTouchX = x - mScrollOffset[<span class="number">0</span>];</span><br><span class="line">                    mLastTouchY = y - mScrollOffset[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (scrollByInternal(</span><br><span class="line">                            canScrollHorizontally ? dx : <span class="number">0</span>,</span><br><span class="line">                            canScrollVertically ? dy : <span class="number">0</span>,</span><br><span class="line">                            vtev)) &#123;</span><br><span class="line">                        getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">                resetTouch();</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!eventAddedToVelocityTracker) &#123;</span><br><span class="line">            mVelocityTracker.addMovement(vtev);</span><br><span class="line">        &#125;</span><br><span class="line">        vtev.recycle();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，是直接调用的方法 startNestedScroll ，那么跟下去看看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNestedScroll</span><span class="params">(<span class="keyword">int</span> axes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getScrollingChildHelper().startNestedScroll(axes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再跟看看 getScrollingChildHelper 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> NestedScrollingChildHelper <span class="title">getScrollingChildHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mScrollingChildHelper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mScrollingChildHelper = <span class="keyword">new</span> NestedScrollingChildHelper(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mScrollingChildHelper;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>一个简单的单例模式，把自己(RecycleView) 传递进去了。那么我们跟下去看看<br>mScrollingChildHelper.startNestedScroll 方法。</p>
<h3 id="mScrollingChildHelper-startNestedScroll_方法">mScrollingChildHelper.startNestedScroll 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Start a new nested scroll for this view.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This is a delegate method. Call it from your &#123;<span class="doctag">@link</span> android.view.View View&#125; subclass</span><br><span class="line"> * method/&#123;<span class="doctag">@link</span> NestedScrollingChild&#125; interface method with the same signature to implement</span><br><span class="line"> * the standard policy.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> axes Supported nested scroll axes.</span><br><span class="line"> *             See &#123;<span class="doctag">@link</span> NestedScrollingChild#startNestedScroll(int)&#125;.</span><br><span class="line"> * <span class="doctag">@return</span> true if a cooperating parent view was found and nested scrolling started successfully</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNestedScroll</span><span class="params">(<span class="keyword">int</span> axes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasNestedScrollingParent()) &#123;</span><br><span class="line">        <span class="comment">// Already in progress</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isNestedScrollingEnabled()) &#123;</span><br><span class="line">        ViewParent p = mView.getParent();</span><br><span class="line">        View child = mView;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ViewParentCompat.onStartNestedScroll(p, child, mView, axes)) &#123;</span><br><span class="line">                mNestedScrollingParent = p;</span><br><span class="line">                ViewParentCompat.onNestedScrollAccepted(p, child, mView, axes);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> View) &#123;</span><br><span class="line">                child = (View) p;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先做了检查，hasNestedScrollingParent 方法就检查了 mNestedScrollingParent 是否为空，<br>如果不为空，就代表已经在嵌套滚动当中了，就不进行其他处理了，直接返回 true。 从后面的代码可以<br>看到 mNestedScrollingParent 的赋值就是 mView 的父类（或者父父类）。<br>接下来我们看 ViewParentCompat.onStartNestedScroll 方法</p>
<h3 id="ViewParentCompat-onStartNestedScroll_方法">ViewParentCompat.onStartNestedScroll 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(ViewParent parent, View child, View target,</span><br><span class="line">        <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IMPL.onStartNestedScroll(parent, child, target, nestedScrollAxes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ViewParentCompatImpl IMPL;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> version = Build.VERSION.SDK_INT;</span><br><span class="line">    <span class="keyword">if</span> (version &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">        IMPL = <span class="keyword">new</span> ViewParentCompatLollipopImpl();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (version &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">        IMPL = <span class="keyword">new</span> ViewParentCompatKitKatImpl();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (version &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">        IMPL = <span class="keyword">new</span> ViewParentCompatICSImpl();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        IMPL = <span class="keyword">new</span> ViewParentCompatStubImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewParentCompatLollipopImpl</span> <span class="keyword">extends</span> <span class="title">ViewParentCompatKitKatImpl</span> </span>&#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(ViewParent parent, View child, View target,</span><br><span class="line">                <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ViewParentCompatLollipop.onStartNestedScroll(parent, child, target,</span><br><span class="line">                    nestedScrollAxes);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewParentCompatStubImpl</span> <span class="keyword">implements</span> <span class="title">ViewParentCompatImpl</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">requestSendAccessibilityEvent</span><span class="params">(</span><br><span class="line">            ViewParent parent, View child, AccessibilityEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Emulate what ViewRootImpl does in ICS and above.</span></span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> AccessibilityManager manager = (AccessibilityManager) child.getContext()</span><br><span class="line">                .getSystemService(Context.ACCESSIBILITY_SERVICE);</span><br><span class="line">        manager.sendAccessibilityEvent(event);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(ViewParent parent, View child, View target,</span><br><span class="line">            <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> NestedScrollingParent) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((NestedScrollingParent) parent).onStartNestedScroll(child, target,</span><br><span class="line">                    nestedScrollAxes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看到，ViewParentCompat 是交给一个成员变量 IMPL 来处理的，这个 IMPL 在<br>不同系统版本又有不同的实现，5.0 以上是 ViewParentCompatLollipopImpl ，5.0 以下 是<br>ViewParentCompatStubImpl ， ViewParentCompat 是一个兼容库，5.0 以上<br>就直接调用 View 或者 ViewGroup 的方法，5.0 以下就看是否实现了<br>NestedScrollingChild 和 NestedScrollingParent ，如果实现了就调用相关的方法，否则啥也<br>不干了。因此 ListView 本身是不支持嵌套滚动的，除非继承 NestedScrollingChild 并且实现<br>相关的方法。  </p>
<h3 id="CoordinatorLayout_的_onStartNestedScroll_方法">CoordinatorLayout 的 onStartNestedScroll 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(View child, View target, <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View view = getChildAt(i);</span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) view.getLayoutParams();</span><br><span class="line">            <span class="keyword">final</span> Behavior viewBehavior = lp.getBehavior();</span><br><span class="line">            <span class="keyword">if</span> (viewBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> accepted = viewBehavior.onStartNestedScroll(<span class="keyword">this</span>, view, child, target,</span><br><span class="line">                        nestedScrollAxes);</span><br><span class="line">                handled |= accepted;</span><br><span class="line"></span><br><span class="line">                lp.acceptNestedScroll(accepted);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lp.acceptNestedScroll(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，就是遍历所有子 View 的 Behavior 的 onStartNestedScroll 方法，并且记录<br>返回值到子 View 的 LayoutParams 中。返回 true ，代表这个 Behavior 想接受这个嵌套滚动。<br>只要有一个 Behavior 返回了 true ，那么这个方法中的返回值 就为 true 。接下来再看看<br>Behavior 的 onStartNestedScroll 方法。</p>
<h3 id="Behavior_的_onStartNestedScroll_方法。">Behavior 的 onStartNestedScroll 方法。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Called when a descendant of the CoordinatorLayout attempts to initiate a nested scroll.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Any Behavior associated with any direct child of the CoordinatorLayout may respond</span><br><span class="line"> * to this event and return true to indicate that the CoordinatorLayout should act as</span><br><span class="line"> * a nested scrolling parent for this scroll. Only Behaviors that return true from</span><br><span class="line"> * this method will receive subsequent nested scroll events.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> coordinatorLayout the CoordinatorLayout parent of the view this Behavior is</span><br><span class="line"> *                          associated with</span><br><span class="line"> * <span class="doctag">@param</span> child the child view of the CoordinatorLayout this Behavior is associated with</span><br><span class="line"> * <span class="doctag">@param</span> directTargetChild the child view of the CoordinatorLayout that either is or</span><br><span class="line"> *                          contains the target of the nested scroll operation</span><br><span class="line"> * <span class="doctag">@param</span> target the descendant view of the CoordinatorLayout initiating the nested scroll</span><br><span class="line"> * <span class="doctag">@param</span> nestedScrollAxes the axes that this nested scroll applies to. See</span><br><span class="line"> *                         &#123;<span class="doctag">@link</span> ViewCompat#SCROLL_AXIS_HORIZONTAL&#125;,</span><br><span class="line"> *                         &#123;<span class="doctag">@link</span> ViewCompat#SCROLL_AXIS_VERTICAL&#125;</span><br><span class="line"> * <span class="doctag">@return</span> true if the Behavior wishes to accept this nested scroll</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@see</span> NestedScrollingParent#onStartNestedScroll(View, View, int)</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(CoordinatorLayout coordinatorLayout,</span><br><span class="line">        V child, View directTargetChild, View target, <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法，默认是返回 false ，几个形参容易搞错。</p>
<ol>
<li>child<br>是指 CoordinatorLayout 的直接子 View ，并且是提供这个 Behavior 的 view 。在这个例子中<br>就是指 RecycleView  了。</li>
<li>directTargetChild<br>是指 CoordinatorLayout 的直接子 View ，包含 target 的 view。也就是说，可能是初始引起嵌套<br>滚动的 View 的父 View 。</li>
<li>target<br>是指 CoordinatorLayout 的后代子 View，初始引起嵌套滚动的 View 。</li>
</ol>
<p>回到 NestedScrollingChild 的 startNestedScroll 方法，如果我们返回 true ，那么我们就<br>回进入到方法 ViewParentCompat.onNestedScrollAccepted(p, child, mView, axes) 。<br>根据我们上面对 ViewParentCompat 理解，这个方法最后就是调用 NestedScrollingParent 中，<br>在我们这个例子中，就是进入到 CoordinatorLayout ,那直接看 CoordinatorLayout<br>的 onNestedScrollAccepted 方法。</p>
<h3 id="CoordinatorLayout_的_onNestedScrollAccepted_方法。">CoordinatorLayout 的 onNestedScrollAccepted 方法。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScrollAccepted</span><span class="params">(View child, View target, <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">    mNestedScrollingParentHelper.onNestedScrollAccepted(child, target, nestedScrollAxes);</span><br><span class="line">    mNestedScrollingDirectChild = child;</span><br><span class="line">    mNestedScrollingTarget = target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View view = getChildAt(i);</span><br><span class="line">        <span class="keyword">final</span> LayoutParams lp = (LayoutParams) view.getLayoutParams();</span><br><span class="line">        <span class="keyword">if</span> (!lp.isNestedScrollAccepted()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Behavior viewBehavior = lp.getBehavior();</span><br><span class="line">        <span class="keyword">if</span> (viewBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">            viewBehavior.onNestedScrollAccepted(<span class="keyword">this</span>, view, child, target, nestedScrollAxes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mNestedScrollingParentHelper 记录了 nestedScrollAxes ,然后就遍历所有子 View 的<br>Behavior ，如果这个 Behavior 在先前的方法 onStartNestedScroll 中返回了 false ，就<br>不会得到接下去的执行。如果返回了 true ，就调用 Behavior 的 onNestedScrollAccepted 方法。<br>意思就是，如果一个嵌套滚动被接受了，就会调用这个方法，Behavior 默认没有做任何处理。  </p>
<h3 id="嵌套中的_Down_事件总结">嵌套中的 Down 事件总结</h3><p>在 Down 事件中，touch 事件从 NestedScrollingChild 传递到 NestedScrollingChildHelper<br>, NestedScrollingParent 等，最终会传递 Behavior ，Behavior 需要表态是否接受这个<br>嵌套滚动，如果不接受，那么这个 Behavior 就不会接受这个嵌套滚动的后面 touch 事件了。<br><strong>但是一个 Behavior 不接受嵌套滚动， 并不会阻止这个 touch 事件接下来的分发流程</strong></p>
<h2 id="嵌套中的_MOVE_事件">嵌套中的 MOVE 事件</h2><p>再回到上面的 RecycleView 的 onTouchEvent 源码部分。</p>
<h3 id="RecycleView_的_dispatchNestedPreScroll_方法">RecycleView 的 dispatchNestedPreScroll 方法</h3><p>改方法会在 RecycleView 的 onTouchEvent 方法中调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedPreScroll</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed, <span class="keyword">int</span>[] offsetInWindow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getScrollingChildHelper().dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="NestedScrollingChildHelper_的_dispatchNestedPreScroll_方法">NestedScrollingChildHelper 的 dispatchNestedPreScroll 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * Dispatch one step of a nested pre-scrolling operation to the current nested scrolling parent.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This is a delegate method. Call it from your &#123;<span class="doctag">@link</span> android.view.View View&#125; subclass</span><br><span class="line">     * method/&#123;<span class="doctag">@link</span> NestedScrollingChild&#125; interface method with the same signature to implement</span><br><span class="line">     * the standard policy.&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span> true if the parent consumed any of the nested scroll</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedPreScroll</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed, <span class="keyword">int</span>[] offsetInWindow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isNestedScrollingEnabled() &amp;&amp; mNestedScrollingParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dx != <span class="number">0</span> || dy != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> startX = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> startY = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (offsetInWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mView.getLocationInWindow(offsetInWindow);</span><br><span class="line">                    startX = offsetInWindow[<span class="number">0</span>];</span><br><span class="line">                    startY = offsetInWindow[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (consumed == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mTempNestedScrollConsumed == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mTempNestedScrollConsumed = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    consumed = mTempNestedScrollConsumed;</span><br><span class="line">                &#125;</span><br><span class="line">                consumed[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                consumed[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                ViewParentCompat.onNestedPreScroll(mNestedScrollingParent, mView, dx, dy, consumed);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (offsetInWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mView.getLocationInWindow(offsetInWindow);</span><br><span class="line">                    offsetInWindow[<span class="number">0</span>] -= startX;</span><br><span class="line">                    offsetInWindow[<span class="number">1</span>] -= startY;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> consumed[<span class="number">0</span>] != <span class="number">0</span> || consumed[<span class="number">1</span>] != <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offsetInWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">                offsetInWindow[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                offsetInWindow[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>几个形参的意思</p>
<ol>
<li>consumed<br>代表 NestedScrollingChild 在 NestedPred 过程中，被 NestedScrollingParent<br>(应该说是他的子 View 的 Behavior )消耗了的距离.</li>
<li>offsetInWindow<br>在 NestedPred 流程中， NestedScrollingChild 相对屏幕左上角，位置的更改值。有可能是<br>NestedScrollingChild 在 NestedPred 过程中， NestedScrollingParent 改变了位置，<br>从而导致 NestedScrollingChild 相对屏幕左上角的位置改变了。  </li>
</ol>
<p>再看 ViewParentCompat.onNestedPreScroll 方法。其实就是看 CoordinatorLayout<br>的 onNestedPreScroll 方法了。</p>
<h3 id="CoordinatorLayout_的_onNestedPreScroll_方法了。">CoordinatorLayout 的 onNestedPreScroll 方法了。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedPreScroll</span><span class="params">(View target, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xConsumed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> yConsumed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> accepted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View view = getChildAt(i);</span><br><span class="line">        <span class="keyword">final</span> LayoutParams lp = (LayoutParams) view.getLayoutParams();</span><br><span class="line">        <span class="keyword">if</span> (!lp.isNestedScrollAccepted()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Behavior viewBehavior = lp.getBehavior();</span><br><span class="line">        <span class="keyword">if</span> (viewBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTempIntPair[<span class="number">0</span>] = mTempIntPair[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            viewBehavior.onNestedPreScroll(<span class="keyword">this</span>, view, target, dx, dy, mTempIntPair);</span><br><span class="line"></span><br><span class="line">            xConsumed = dx &gt; <span class="number">0</span> ? Math.max(xConsumed, mTempIntPair[<span class="number">0</span>])</span><br><span class="line">                    : Math.min(xConsumed, mTempIntPair[<span class="number">0</span>]);</span><br><span class="line">            yConsumed = dy &gt; <span class="number">0</span> ? Math.max(yConsumed, mTempIntPair[<span class="number">1</span>])</span><br><span class="line">                    : Math.min(yConsumed, mTempIntPair[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            accepted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    consumed[<span class="number">0</span>] = xConsumed;</span><br><span class="line">    consumed[<span class="number">1</span>] = yConsumed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (accepted) &#123;</span><br><span class="line">        dispatchOnDependentViewChanged(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里可以看到，consumed 的值取所有所有 Behavior 消耗的最极端值（是区分了正负）。<br>这意味着，NestedScrollingChildHelper.dispatchNestedPreScroll 的 consumed<br>是 NestedScrollingParent 的 Behavior 消耗了的。</p>
<h3 id="再看_CoordinatorLayout_的_dispatchOnDependentViewChanged_方法">再看 CoordinatorLayout 的  dispatchOnDependentViewChanged 方法</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * Dispatch any dependent view changes to the relevant &#123;<span class="doctag">@link</span> Behavior&#125; instances.</span><br><span class="line">     *</span><br><span class="line">     * Usually run as part of the pre-draw step when at least one child view has a reported</span><br><span class="line">     * dependency on another view. This allows CoordinatorLayout to account for layout</span><br><span class="line">     * changes and animations that occur outside of the normal layout pass.</span><br><span class="line">     *</span><br><span class="line">     * It can also be ran as part of the nested scrolling dispatch to ensure that any offsetting</span><br><span class="line">     * is completed within the correct coordinate window.</span><br><span class="line">     *</span><br><span class="line">     * The offsetting behavior implemented here does not store the computed offset in</span><br><span class="line">     * the LayoutParams; instead it expects that the layout process will always reconstruct</span><br><span class="line">     * the proper positioning.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> fromNestedScroll true if this is being called from one of the nested scroll methods,</span><br><span class="line">     *                         false if run as part of the pre-draw step.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispatchOnDependentViewChanged</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> fromNestedScroll)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = ViewCompat.getLayoutDirection(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = mDependencySortedChildren.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = mDependencySortedChildren.get(i);</span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check child views before for anchor</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">final</span> View checkChild = mDependencySortedChildren.get(j);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (lp.mAnchorDirectChild == checkChild) &#123;</span><br><span class="line">                    offsetChildToAnchor(child, layoutDirection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Did it change? if not continue</span></span><br><span class="line">            <span class="keyword">final</span> Rect oldRect = mTempRect1;</span><br><span class="line">            <span class="keyword">final</span> Rect newRect = mTempRect2;</span><br><span class="line">            getLastChildRect(child, oldRect);</span><br><span class="line">            getChildRect(child, <span class="keyword">true</span>, newRect);</span><br><span class="line">            <span class="keyword">if</span> (oldRect.equals(newRect)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            recordLastChildRect(child, newRect);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Update any behavior-dependent views for the change</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; childCount; j++) &#123;</span><br><span class="line">                <span class="keyword">final</span> View checkChild = mDependencySortedChildren.get(j);</span><br><span class="line">                <span class="keyword">final</span> LayoutParams checkLp = (LayoutParams) checkChild.getLayoutParams();</span><br><span class="line">                <span class="keyword">final</span> Behavior b = checkLp.getBehavior();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (b != <span class="keyword">null</span> &amp;&amp; b.layoutDependsOn(<span class="keyword">this</span>, checkChild, child)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!fromNestedScroll &amp;&amp; checkLp.getChangedAfterNestedScroll()) &#123;</span><br><span class="line">                        <span class="comment">// If this is not from a nested scroll and we have already been changed</span></span><br><span class="line">                        <span class="comment">// from a nested scroll, skip the dispatch and reset the flag</span></span><br><span class="line">                        checkLp.resetChangedAfterNestedScroll();</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> handled = b.onDependentViewChanged(<span class="keyword">this</span>, checkChild, child);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (fromNestedScroll) &#123;</span><br><span class="line">                        <span class="comment">// If this is from a nested scroll, set the flag so that we may skip</span></span><br><span class="line">                        <span class="comment">// any resulting onPreDraw dispatch (if needed)</span></span><br><span class="line">                        checkLp.setChangedAfterNestedScroll(handled);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 这里可能会调用 Behavior 的2个方法<br> layoutDependsOn 和 onDependentViewChanged 方法。</p>
<h3 id="Behavior_的_layoutDependsOn_方法">Behavior 的 layoutDependsOn 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Determine whether the supplied child view has another specific sibling view as a</span><br><span class="line"> * layout dependency.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This method will be called at least once in response to a layout request. If it</span><br><span class="line"> * returns true for a given child and dependency view pair, the parent CoordinatorLayout</span><br><span class="line"> * will:&lt;/p&gt;</span><br><span class="line"> * &lt;ol&gt;</span><br><span class="line"> *     &lt;li&gt;Always lay out this child after the dependent child is laid out, regardless</span><br><span class="line"> *     of child order.&lt;/li&gt;</span><br><span class="line"> *     &lt;li&gt;Call &#123;<span class="doctag">@link</span> #onDependentViewChanged&#125; when the dependency view's layout or</span><br><span class="line"> *     position changes.&lt;/li&gt;</span><br><span class="line"> * &lt;/ol&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> parent the parent view of the given child</span><br><span class="line"> * <span class="doctag">@param</span> child the child view to test</span><br><span class="line"> * <span class="doctag">@param</span> dependency the proposed dependency of child</span><br><span class="line"> * <span class="doctag">@return</span> true if child's layout depends on the proposed dependency's layout,</span><br><span class="line"> *         false otherwise</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@see</span> #onDependentViewChanged(CoordinatorLayout, android.view.View, android.view.View)</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">layoutDependsOn</span><span class="params">(CoordinatorLayout parent, V child, View dependency)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>形参的含义<br> 询问 child 到底是否依赖 dependency 。如果返回 true ， CoordinatorLayout 会在<br> lay out 完 dependency 之后，不管 child 顺序，就 lay out 这个形参 child 了。</p>
<h3 id="Behavior_的_onDependentViewChanged_方法">Behavior 的 onDependentViewChanged 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Respond to a change in a child's dependent view</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This method is called whenever a dependent view changes in size or position outside</span><br><span class="line"> * of the standard layout flow. A Behavior may use this method to appropriately update</span><br><span class="line"> * the child view in response.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;A view's dependency is determined by</span><br><span class="line"> * &#123;<span class="doctag">@link</span> #layoutDependsOn(CoordinatorLayout, android.view.View, android.view.View)&#125; or</span><br><span class="line"> * if &#123;<span class="doctag">@code</span> child&#125; has set another view as it's anchor.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Note that if a Behavior changes the layout of a child via this method, it should</span><br><span class="line"> * also be able to reconstruct the correct position in</span><br><span class="line"> * &#123;<span class="doctag">@link</span> #onLayoutChild(CoordinatorLayout, android.view.View, int) onLayoutChild&#125;.</span><br><span class="line"> * &lt;code&gt;onDependentViewChanged&lt;/code&gt; will not be called during normal layout since</span><br><span class="line"> * the layout of each child view will always happen in dependency order.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;If the Behavior changes the child view's size or position, it should return true.</span><br><span class="line"> * The default implementation returns false.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> parent the parent view of the given child</span><br><span class="line"> * <span class="doctag">@param</span> child the child view to manipulate</span><br><span class="line"> * <span class="doctag">@param</span> dependency the dependent view that changed</span><br><span class="line"> * <span class="doctag">@return</span> true if the Behavior changed the child view's size or position, false otherwise</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDependentViewChanged</span><span class="params">(CoordinatorLayout parent, V child, View dependency)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当 dependency 改变了位置或者大小的时候，都会触发此方法，这个方法是一个恰当的时机去改变<br>形参中的 child view 。如果在这个方法里面改变了 child 的位置或者大小，必须可以在<br>CoordinatorLayout 的 onLayoutChild 中可以复原。<strong>undo 意味着，改变 left top 没效咯？</strong><br><strong>mark</strong><br>在 Behavior 的方法 onLayoutChild 注解中可以看到，实现了 onDependentViewChanged<br>，那么也应该实现 onLayoutChild 方法。<br>如果改变了 child ，该方法就应该返回  true 。</p>
<h3 id="嵌套的_Move_事件中的_NestedPre_过程小结">嵌套的 Move 事件中的 NestedPre 过程小结</h3><p>由 NestedScrollingChild.dispatchNestedPreScroll 发起，最后给到<br>NestedScrollingParent 的 Behavior 来消费。  </p>
<ol>
<li>需要注意的是，在 NestedScrollingChild 中，需要对 Behavior 消费的距离，<br>以及因为 NestedScrollingParent 改变位置，导致 NestedScrollingChild<br>相对屏幕左上角坐标的改变，做相应的调整。  </li>
<li>layoutDependsOn 返回 true 的话，会接着调用 onDependentViewChanged ，此方法<br>是一个比较恰当的时机去改变 child ，但是需要注意需要保证在 CoordinatorLayout  的<br>onLayoutChild 方法中可以复原。</li>
</ol>
<h3 id="再回到_RecycleView_的_onTouchEvent_和_scrollByInternal_方法">再回到 RecycleView 的 onTouchEvent 和 scrollByInternal 方法</h3><p>可以看到调用了 RecycleView 的 scrollByInternal 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * Does not perform bounds checking. Used by internal methods that have already validated input.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * It also reports any unused scroll request to the related EdgeEffect.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> x The amount of horizontal scroll request</span><br><span class="line">     * <span class="doctag">@param</span> y The amount of vertical scroll request</span><br><span class="line">     * <span class="doctag">@param</span> ev The originating MotionEvent, or null if not from a touch event.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span> Whether any scroll was consumed in either direction.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">scrollByInternal</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> unconsumedX = <span class="number">0</span>, unconsumedY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> consumedX = <span class="number">0</span>, consumedY = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        consumePendingUpdateOperations();</span><br><span class="line">        <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            eatRequestLayout();</span><br><span class="line">            onEnterLayoutOrScroll();</span><br><span class="line">            TraceCompat.beginSection(TRACE_SCROLL_TAG);</span><br><span class="line">            <span class="keyword">if</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">                consumedX = mLayout.scrollHorizontallyBy(x, mRecycler, mState);</span><br><span class="line">                unconsumedX = x - consumedX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (y != <span class="number">0</span>) &#123;</span><br><span class="line">                consumedY = mLayout.scrollVerticallyBy(y, mRecycler, mState);</span><br><span class="line">                unconsumedY = y - consumedY;</span><br><span class="line">            &#125;</span><br><span class="line">            TraceCompat.endSection();</span><br><span class="line">            repositionShadowingViews();</span><br><span class="line">            onExitLayoutOrScroll();</span><br><span class="line">            resumeRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!mItemDecorations.isEmpty()) &#123;</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dispatchNestedScroll(consumedX, consumedY, unconsumedX, unconsumedY, mScrollOffset)) &#123;</span><br><span class="line">            <span class="comment">// Update the last touch co-ords, taking any scroll offset into account</span></span><br><span class="line">            mLastTouchX -= mScrollOffset[<span class="number">0</span>];</span><br><span class="line">            mLastTouchY -= mScrollOffset[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (ev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ev.offsetLocation(mScrollOffset[<span class="number">0</span>], mScrollOffset[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            mNestedOffsets[<span class="number">0</span>] += mScrollOffset[<span class="number">0</span>];</span><br><span class="line">            mNestedOffsets[<span class="number">1</span>] += mScrollOffset[<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ViewCompat.getOverScrollMode(<span class="keyword">this</span>) != ViewCompat.OVER_SCROLL_NEVER) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pullGlows(ev.getX(), unconsumedX, ev.getY(), unconsumedY);</span><br><span class="line">            &#125;</span><br><span class="line">            considerReleasingGlowsOnScroll(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (consumedX != <span class="number">0</span> || consumedY != <span class="number">0</span>) &#123;</span><br><span class="line">            dispatchOnScrolled(consumedX, consumedY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!awakenScrollBars()) &#123;</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> consumedX != <span class="number">0</span> || consumedY != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>和嵌套滚动相关的，就是调用了 dispatchNestedScroll ，这个方法里面，实际就是调用了<br>NestedScrollingChild 的 dispatchNestedScroll 方法。</p>
<h3 id="NestedScrollingChild_的_dispatchNestedScroll_方法。">NestedScrollingChild 的 dispatchNestedScroll 方法。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * Dispatch one step of a nested scrolling operation to the current nested scrolling parent.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This is a delegate method. Call it from your &#123;<span class="doctag">@link</span> android.view.View View&#125; subclass</span><br><span class="line">     * method/&#123;<span class="doctag">@link</span> NestedScrollingChild&#125; interface method with the same signature to implement</span><br><span class="line">     * the standard policy.&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span> true if the parent consumed any of the nested scroll</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedScroll</span><span class="params">(<span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed,</span><br><span class="line">            <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed, <span class="keyword">int</span>[] offsetInWindow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isNestedScrollingEnabled() &amp;&amp; mNestedScrollingParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dxConsumed != <span class="number">0</span> || dyConsumed != <span class="number">0</span> || dxUnconsumed != <span class="number">0</span> || dyUnconsumed != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> startX = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> startY = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (offsetInWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mView.getLocationInWindow(offsetInWindow);</span><br><span class="line">                    startX = offsetInWindow[<span class="number">0</span>];</span><br><span class="line">                    startY = offsetInWindow[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ViewParentCompat.onNestedScroll(mNestedScrollingParent, mView, dxConsumed,</span><br><span class="line">                        dyConsumed, dxUnconsumed, dyUnconsumed);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (offsetInWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mView.getLocationInWindow(offsetInWindow);</span><br><span class="line">                    offsetInWindow[<span class="number">0</span>] -= startX;</span><br><span class="line">                    offsetInWindow[<span class="number">1</span>] -= startY;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offsetInWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No motion, no dispatch. Keep offsetInWindow up to date.</span></span><br><span class="line">                offsetInWindow[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                offsetInWindow[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里，又算了下，让 NestedScrollingParent 的位置改变，导致 NestedScrollingChild<br>相对屏幕左上角的改变。用 offsetInWindow 记录了。 NestedScrollingChild 可能需要对<br>这个做相应的处理。中间调用的 ViewParentCompat.onNestedScroll 实际就是调用的<br>CoordinatorLayout 的 onNestedScroll</p>
<h3 id="CoordinatorLayout_的_onNestedScroll">CoordinatorLayout 的 onNestedScroll</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(View target, <span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed,</span><br><span class="line">            <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">        <span class="keyword">boolean</span> accepted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View view = getChildAt(i);</span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) view.getLayoutParams();</span><br><span class="line">            <span class="keyword">if</span> (!lp.isNestedScrollAccepted()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Behavior viewBehavior = lp.getBehavior();</span><br><span class="line">            <span class="keyword">if</span> (viewBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">                viewBehavior.onNestedScroll(<span class="keyword">this</span>, view, target, dxConsumed, dyConsumed,</span><br><span class="line">                        dxUnconsumed, dyUnconsumed);</span><br><span class="line">                accepted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (accepted) &#123;</span><br><span class="line">            dispatchOnDependentViewChanged(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其实都是给 Behavior 来处理了。</p>
<h3 id="嵌套滚动中_MOVE_事件整体小结">嵌套滚动中 MOVE 事件整体小结</h3><p>在 NestedPre 中，NestedScrollingChild 告诉 NestedScrollingParent 有多少滚动距离，<br>NestedScrollingParent 把滚动都给 Behavior 的 onNestedPreScroll 来处理，消费了多少，<br>需要记录下来，并告诉 NestedScrollingParent .这个 NestedScrollingParent 的 Behavior<br>消耗了多少，告诉 NestedScrollingChild 使用的方式是， NestedScrollingChild 传递<br>一个引用给 NestedScrollingParent ，NestedScrollingParent 再修改这个引用指向的对象<br>部分的属性.  </p>
<p>在 Nested 中，NestedScrollingChild 自己消费一部分，告诉 NestedScrollingParent<br>自己消费了多少，没有消费的还有多少，NestedScrollingParent 再全部告诉 Behavior 。  </p>
<p><strong>标准的做法就是</strong></p>
<ul>
<li>自己先不消耗滚动距离，让 NestedScrollingParent 的 onNestedPreScroll<br>方法优先消费滚动距离。然后 中，NestedScrollingChild 记录一下这个过程中消费的距离。</li>
<li>中，NestedScrollingChild 自己消耗一下滚动距离.</li>
<li>然后 中，NestedScrollingChild 把已经消费了的，和未消费的，给到 NestedScrollingParent<br>的方法 onNestedScroll 。</li>
</ul>
<h2 id="嵌套中的_UP_事件">嵌套中的 UP 事件</h2><p>这个就比较简单了，就是调用 NestedScrollingChild 的 stopNestedScroll ，接着<br>NestedScrollingChildHelper  的 stopNestedScroll ，最后就是<br>NestedScrollingParent 的 Behavior 的 stopNestedScroll 了。</p>
</span>
      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/06/12/CoordinatorLayout-源码学习/" rel="next" title="CoordinatorLayout 源码学习">
                <i class="fa fa-chevron-left"></i> CoordinatorLayout 源码学习
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/06/20/post-Behavior-细节笔记/" rel="prev" title="Behavior 细节笔记">
                Behavior 细节笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


        </div>

        


        
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/06/13/NestedScrolling-流程理解/"
           data-title="NestedScrolling 流程理解" data-url="http://www.aheadlcx.xyz/2016/06/13/NestedScrolling-流程理解/">
      </div>
    
  </div>


      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="https://avatars1.githubusercontent.com/u/32269?v=3&s=460" alt="aheadlcx" itemprop="image"/>
          <p class="site-author-name" itemprop="name">aheadlcx</p>
        </div>
        <p class="site-description motion-element" itemprop="description"></p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">23</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">3</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">14</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类简介"><span class="nav-number">2.</span> <span class="nav-text">类简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#NestedScrollingChild"><span class="nav-number">2.1.</span> <span class="nav-text">NestedScrollingChild</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NestedScrollingChildHelper"><span class="nav-number">2.2.</span> <span class="nav-text">NestedScrollingChildHelper</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NestedScrollingParent"><span class="nav-number">2.3.</span> <span class="nav-text">NestedScrollingParent</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NestedScrollingParentHelper"><span class="nav-number">2.4.</span> <span class="nav-text">NestedScrollingParentHelper</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#嵌套滚动原理"><span class="nav-number">3.</span> <span class="nav-text">嵌套滚动原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#嵌套中的_DWON_事件"><span class="nav-number">3.1.</span> <span class="nav-text">嵌套中的 DWON 事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#起始于_RecycleView_中的_onTouchEvent"><span class="nav-number">3.1.1.</span> <span class="nav-text">起始于 RecycleView 中的 onTouchEvent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mScrollingChildHelper-startNestedScroll_方法"><span class="nav-number">3.1.2.</span> <span class="nav-text">mScrollingChildHelper.startNestedScroll 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ViewParentCompat-onStartNestedScroll_方法"><span class="nav-number">3.1.3.</span> <span class="nav-text">ViewParentCompat.onStartNestedScroll 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CoordinatorLayout_的_onStartNestedScroll_方法"><span class="nav-number">3.1.4.</span> <span class="nav-text">CoordinatorLayout 的 onStartNestedScroll 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Behavior_的_onStartNestedScroll_方法。"><span class="nav-number">3.1.5.</span> <span class="nav-text">Behavior 的 onStartNestedScroll 方法。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CoordinatorLayout_的_onNestedScrollAccepted_方法。"><span class="nav-number">3.1.6.</span> <span class="nav-text">CoordinatorLayout 的 onNestedScrollAccepted 方法。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#嵌套中的_Down_事件总结"><span class="nav-number">3.1.7.</span> <span class="nav-text">嵌套中的 Down 事件总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#嵌套中的_MOVE_事件"><span class="nav-number">3.2.</span> <span class="nav-text">嵌套中的 MOVE 事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RecycleView_的_dispatchNestedPreScroll_方法"><span class="nav-number">3.2.1.</span> <span class="nav-text">RecycleView 的 dispatchNestedPreScroll 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NestedScrollingChildHelper_的_dispatchNestedPreScroll_方法"><span class="nav-number">3.2.2.</span> <span class="nav-text">NestedScrollingChildHelper 的 dispatchNestedPreScroll 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CoordinatorLayout_的_onNestedPreScroll_方法了。"><span class="nav-number">3.2.3.</span> <span class="nav-text">CoordinatorLayout 的 onNestedPreScroll 方法了。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#再看_CoordinatorLayout_的_dispatchOnDependentViewChanged_方法"><span class="nav-number">3.2.4.</span> <span class="nav-text">再看 CoordinatorLayout 的  dispatchOnDependentViewChanged 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Behavior_的_layoutDependsOn_方法"><span class="nav-number">3.2.5.</span> <span class="nav-text">Behavior 的 layoutDependsOn 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Behavior_的_onDependentViewChanged_方法"><span class="nav-number">3.2.6.</span> <span class="nav-text">Behavior 的 onDependentViewChanged 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#嵌套的_Move_事件中的_NestedPre_过程小结"><span class="nav-number">3.2.7.</span> <span class="nav-text">嵌套的 Move 事件中的 NestedPre 过程小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#再回到_RecycleView_的_onTouchEvent_和_scrollByInternal_方法"><span class="nav-number">3.2.8.</span> <span class="nav-text">再回到 RecycleView 的 onTouchEvent 和 scrollByInternal 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NestedScrollingChild_的_dispatchNestedScroll_方法。"><span class="nav-number">3.2.9.</span> <span class="nav-text">NestedScrollingChild 的 dispatchNestedScroll 方法。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CoordinatorLayout_的_onNestedScroll"><span class="nav-number">3.2.10.</span> <span class="nav-text">CoordinatorLayout 的 onNestedScroll</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#嵌套滚动中_MOVE_事件整体小结"><span class="nav-number">3.2.11.</span> <span class="nav-text">嵌套滚动中 MOVE 事件整体小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#嵌套中的_UP_事件"><span class="nav-number">3.3.</span> <span class="nav-text">嵌套中的 UP 事件</span></a></li></ol></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aheadlcx</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"aheadlcx"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     


    
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
<script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

<script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script>


  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.2" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    motionMiddleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');
      if (CONFIG.sidebar === 'post') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          displaySidebar();
        }
      }
    };
  });
</script>



  <script type="text/javascript" src="/js/bootstrap.js"></script>

  
  

  
  

</body>
</html>
