<!doctype html>
<html class="theme-next   use-motion ">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
    <link href='//fonts.lug.ustc.edu.cn/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />













<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Believe yourself">
<meta property="og:url" content="http://www.aheadlcx.xyz/page/3/index.html">
<meta property="og:site_name" content="Believe yourself">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Believe yourself">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post',
    motion: true
  };
</script>

  <title> Believe yourself </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Believe yourself</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <section id="posts" class="posts-expand">

    

    
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/13/NestedScrolling-流程理解/" itemprop="url">
                  NestedScrolling 流程理解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-06-13T15:57:52+08:00" content="2016-06-13">
              2016-06-13
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>参考文章</p>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000002873657" target="_blank" rel="external">Android 嵌套滑动机制（NestedScrolling）</a></p>
</blockquote>
<h1 id="前言">前言</h1><p>传统的 Android 的 Touch 事件分发机制，主要涉及到下面3个方法  </p>
<ol>
<li>dispatchTouchEvent</li>
<li>onInterceptTouchEvent</li>
<li>onTouchEvent</li>
</ol>
<p>其中后面2个方法，是在第一个方法 dispatchTouchEvent 中调用的。在这个涉及里面下，如果父 View<br>把 touch 事件传递给子 View ，并且子 View 消费了这个事件，那么父 View 就再也不能获得这个<br>touch 事件了。（其实这不是绝对的，只是传统的 Android Touch 事件传递设计初衷就这样，<br>子 View 的 Touch 事件也是经过父 View 的 dispatchTouchEvent 方法的嘛），这种设计，只是<br>不能让父 View 和子 View ，经过交流，来回的传递 Touch 事件。  </p>
<p>在 design 中出现了新的设计实现，还可以兼容旧版本，就是 NestedScrolling 了，<br>就是嵌套滚动的意思 。这套设计的实现，主要涉及到下面几个接口（类）  </p>
<ol>
<li>NestedScrollingChild</li>
<li>NestedScrollingChildHelper</li>
<li>NestedScrollingParent</li>
<li>NestedScrollingParentHelper</li>
</ol>
<h1 id="类简介">类简介</h1><h2 id="NestedScrollingChild">NestedScrollingChild</h2><p><img src="https://raw.githubusercontent.com/aheadlcx/myPhotos/master/NestedScroll/NestedScrollingChild.png" alt=""><br>如果想要配合 ViewGroup 实现嵌套滚动， View 或者 View 的子类就得实现接口<br>NestedScrollingChild .并且需要创建一个 final 的 NestedScrollingChildHelper 作为<br>成员变量，并且将相同点方法签名，都交给 NestedScrollingChildHelper 来代理。</p>
<h2 id="NestedScrollingChildHelper">NestedScrollingChildHelper</h2><p><img src="https://raw.githubusercontent.com/aheadlcx/myPhotos/master/NestedScroll/NestedScrollingChildHelper.png" alt=""><br>这是一个帮助工具类，来实现嵌套滚动的，兼容5.0以前的版本。<br>View 的子类应该创建一个 NestedScrollingChildHelper final 实例，并且把 View 和<br>NestedScrollingChildHelper ，方法签名相同的方法，都委托给  NestedScrollingChildHelper<br>来处理。</p>
<h2 id="NestedScrollingParent">NestedScrollingParent</h2><p><img src="https://raw.githubusercontent.com/aheadlcx/myPhotos/master/NestedScroll/NestedScrollingParent.png" alt=""><br>ViewGroup 的子类应该实现的接口，并且需要创建一个 final 的成员变量<br>NestedScrollingParentHelper ，和 NestedScrollingChild 类似。</p>
<h2 id="NestedScrollingParentHelper">NestedScrollingParentHelper</h2><p><img src="https://raw.githubusercontent.com/aheadlcx/myPhotos/master/NestedScroll/NestedScrollingParentHelper.png" alt=""><br>作用和 NestedScrollingChildHelper 类似。</p>
<h1 id="嵌套滚动原理">嵌套滚动原理</h1><p>我们知道新版本的 RecycleView 是支持嵌套滚动的，所以我们直接抓源码看就好了。<br>我们用 RecycleView 作为 NestedScrollingChild ， CoordinatorLayout 作为<br>NestedScrollingParent 来做例子分析。在这个例子中，整个嵌套 touch 事件分发的流程图如下  </p>
<p><img src="https://raw.githubusercontent.com/aheadlcx/myPhotos/master/NestedScroll/NestedScroll_Processon.png" alt=""></p>
<p>整个流程涉及到的类比较多，而且逻辑也比较复杂。总体而言，需要一个 CoordinatorLayout 直接<br>包裹住所有直接子 View （这也不是绝对的，不过这就是人家的设计，如果需要，当然可以重新自定义<br>一个类似于 CoordinatorLayout 的 ViewGroup 了）。如果直接子 View 的 Behavior  没有拦截<br>touch 事件的话，那么嵌套事件就是从子 View 开始发起的。这里先分开3部分来看，分别从 DOWN ，<br>MOVE 和 UP 事件来看。</p>
<h2 id="嵌套中的_DWON_事件">嵌套中的 DWON 事件</h2><h3 id="起始于_RecycleView_中的_onTouchEvent">起始于 RecycleView 中的 onTouchEvent</h3><p>直接上代码 (精简版)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> canScrollHorizontally = mLayout.canScrollHorizontally();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> canScrollVertically = mLayout.canScrollVertically();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> eventAddedToVelocityTracker = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> MotionEvent vtev = MotionEvent.obtain(e);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(e);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = MotionEventCompat.getActionIndex(e);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> nestedScrollAxis = ViewCompat.SCROLL_AXIS_NONE;</span><br><span class="line">                <span class="keyword">if</span> (canScrollHorizontally) &#123;</span><br><span class="line">                    nestedScrollAxis |= ViewCompat.SCROLL_AXIS_HORIZONTAL;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (canScrollVertically) &#123;</span><br><span class="line">                    nestedScrollAxis |= ViewCompat.SCROLL_AXIS_VERTICAL;</span><br><span class="line">                &#125;</span><br><span class="line">                startNestedScroll(nestedScrollAxis);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> x = (<span class="keyword">int</span>) (MotionEventCompat.getX(e, index) + <span class="number">0.5f</span>);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> y = (<span class="keyword">int</span>) (MotionEventCompat.getY(e, index) + <span class="number">0.5f</span>);</span><br><span class="line">                <span class="keyword">int</span> dx = mLastTouchX - x;</span><br><span class="line">                <span class="keyword">int</span> dy = mLastTouchY - y;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dispatchNestedPreScroll(dx, dy, mScrollConsumed, mScrollOffset)) &#123;</span><br><span class="line">                    dx -= mScrollConsumed[<span class="number">0</span>];</span><br><span class="line">                    dy -= mScrollConsumed[<span class="number">1</span>];</span><br><span class="line">                    vtev.offsetLocation(mScrollOffset[<span class="number">0</span>], mScrollOffset[<span class="number">1</span>]);</span><br><span class="line">                    <span class="comment">// Updated the nested offsets</span></span><br><span class="line">                    mNestedOffsets[<span class="number">0</span>] += mScrollOffset[<span class="number">0</span>];</span><br><span class="line">                    mNestedOffsets[<span class="number">1</span>] += mScrollOffset[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mScrollState != SCROLL_STATE_DRAGGING) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> startScroll = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (canScrollHorizontally &amp;&amp; Math.abs(dx) &gt; mTouchSlop) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (dx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            dx -= mTouchSlop;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            dx += mTouchSlop;</span><br><span class="line">                        &#125;</span><br><span class="line">                        startScroll = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (canScrollVertically &amp;&amp; Math.abs(dy) &gt; mTouchSlop) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (dy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            dy -= mTouchSlop;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            dy += mTouchSlop;</span><br><span class="line">                        &#125;</span><br><span class="line">                        startScroll = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (startScroll) &#123;</span><br><span class="line">                        setScrollState(SCROLL_STATE_DRAGGING);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mScrollState == SCROLL_STATE_DRAGGING) &#123;</span><br><span class="line">                    mLastTouchX = x - mScrollOffset[<span class="number">0</span>];</span><br><span class="line">                    mLastTouchY = y - mScrollOffset[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (scrollByInternal(</span><br><span class="line">                            canScrollHorizontally ? dx : <span class="number">0</span>,</span><br><span class="line">                            canScrollVertically ? dy : <span class="number">0</span>,</span><br><span class="line">                            vtev)) &#123;</span><br><span class="line">                        getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">                resetTouch();</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!eventAddedToVelocityTracker) &#123;</span><br><span class="line">            mVelocityTracker.addMovement(vtev);</span><br><span class="line">        &#125;</span><br><span class="line">        vtev.recycle();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，是直接调用的方法 startNestedScroll ，那么跟下去看看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNestedScroll</span><span class="params">(<span class="keyword">int</span> axes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getScrollingChildHelper().startNestedScroll(axes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再跟看看 getScrollingChildHelper 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> NestedScrollingChildHelper <span class="title">getScrollingChildHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mScrollingChildHelper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mScrollingChildHelper = <span class="keyword">new</span> NestedScrollingChildHelper(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mScrollingChildHelper;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>一个简单的单例模式，把自己(RecycleView) 传递进去了。那么我们跟下去看看<br>mScrollingChildHelper.startNestedScroll 方法。</p>
<h3 id="mScrollingChildHelper-startNestedScroll_方法">mScrollingChildHelper.startNestedScroll 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Start a new nested scroll for this view.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This is a delegate method. Call it from your &#123;<span class="doctag">@link</span> android.view.View View&#125; subclass</span><br><span class="line"> * method/&#123;<span class="doctag">@link</span> NestedScrollingChild&#125; interface method with the same signature to implement</span><br><span class="line"> * the standard policy.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> axes Supported nested scroll axes.</span><br><span class="line"> *             See &#123;<span class="doctag">@link</span> NestedScrollingChild#startNestedScroll(int)&#125;.</span><br><span class="line"> * <span class="doctag">@return</span> true if a cooperating parent view was found and nested scrolling started successfully</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNestedScroll</span><span class="params">(<span class="keyword">int</span> axes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasNestedScrollingParent()) &#123;</span><br><span class="line">        <span class="comment">// Already in progress</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isNestedScrollingEnabled()) &#123;</span><br><span class="line">        ViewParent p = mView.getParent();</span><br><span class="line">        View child = mView;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ViewParentCompat.onStartNestedScroll(p, child, mView, axes)) &#123;</span><br><span class="line">                mNestedScrollingParent = p;</span><br><span class="line">                ViewParentCompat.onNestedScrollAccepted(p, child, mView, axes);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> View) &#123;</span><br><span class="line">                child = (View) p;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先做了检查，hasNestedScrollingParent 方法就检查了 mNestedScrollingParent 是否为空，<br>如果不为空，就代表已经在嵌套滚动当中了，就不进行其他处理了，直接返回 true。 从后面的代码可以<br>看到 mNestedScrollingParent 的赋值就是 mView 的父类（或者父父类）。<br>接下来我们看 ViewParentCompat.onStartNestedScroll 方法</p>
<h3 id="ViewParentCompat-onStartNestedScroll_方法">ViewParentCompat.onStartNestedScroll 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(ViewParent parent, View child, View target,</span><br><span class="line">        <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IMPL.onStartNestedScroll(parent, child, target, nestedScrollAxes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ViewParentCompatImpl IMPL;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> version = Build.VERSION.SDK_INT;</span><br><span class="line">    <span class="keyword">if</span> (version &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">        IMPL = <span class="keyword">new</span> ViewParentCompatLollipopImpl();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (version &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">        IMPL = <span class="keyword">new</span> ViewParentCompatKitKatImpl();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (version &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">        IMPL = <span class="keyword">new</span> ViewParentCompatICSImpl();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        IMPL = <span class="keyword">new</span> ViewParentCompatStubImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewParentCompatLollipopImpl</span> <span class="keyword">extends</span> <span class="title">ViewParentCompatKitKatImpl</span> </span>&#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(ViewParent parent, View child, View target,</span><br><span class="line">                <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ViewParentCompatLollipop.onStartNestedScroll(parent, child, target,</span><br><span class="line">                    nestedScrollAxes);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewParentCompatStubImpl</span> <span class="keyword">implements</span> <span class="title">ViewParentCompatImpl</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">requestSendAccessibilityEvent</span><span class="params">(</span><br><span class="line">            ViewParent parent, View child, AccessibilityEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Emulate what ViewRootImpl does in ICS and above.</span></span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> AccessibilityManager manager = (AccessibilityManager) child.getContext()</span><br><span class="line">                .getSystemService(Context.ACCESSIBILITY_SERVICE);</span><br><span class="line">        manager.sendAccessibilityEvent(event);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(ViewParent parent, View child, View target,</span><br><span class="line">            <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> NestedScrollingParent) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((NestedScrollingParent) parent).onStartNestedScroll(child, target,</span><br><span class="line">                    nestedScrollAxes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看到，ViewParentCompat 是交给一个成员变量 IMPL 来处理的，这个 IMPL 在<br>不同系统版本又有不同的实现，5.0 以上是 ViewParentCompatLollipopImpl ，5.0 以下 是<br>ViewParentCompatStubImpl ， ViewParentCompat 是一个兼容库，5.0 以上<br>就直接调用 View 或者 ViewGroup 的方法，5.0 以下就看是否实现了<br>NestedScrollingChild 和 NestedScrollingParent ，如果实现了就调用相关的方法，否则啥也<br>不干了。因此 ListView 本身是不支持嵌套滚动的，除非继承 NestedScrollingChild 并且实现<br>相关的方法。  </p>
<h3 id="CoordinatorLayout_的_onStartNestedScroll_方法">CoordinatorLayout 的 onStartNestedScroll 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(View child, View target, <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View view = getChildAt(i);</span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) view.getLayoutParams();</span><br><span class="line">            <span class="keyword">final</span> Behavior viewBehavior = lp.getBehavior();</span><br><span class="line">            <span class="keyword">if</span> (viewBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> accepted = viewBehavior.onStartNestedScroll(<span class="keyword">this</span>, view, child, target,</span><br><span class="line">                        nestedScrollAxes);</span><br><span class="line">                handled |= accepted;</span><br><span class="line"></span><br><span class="line">                lp.acceptNestedScroll(accepted);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lp.acceptNestedScroll(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，就是遍历所有子 View 的 Behavior 的 onStartNestedScroll 方法，并且记录<br>返回值到子 View 的 LayoutParams 中。返回 true ，代表这个 Behavior 想接受这个嵌套滚动。<br>只要有一个 Behavior 返回了 true ，那么这个方法中的返回值 就为 true 。接下来再看看<br>Behavior 的 onStartNestedScroll 方法。</p>
<h3 id="Behavior_的_onStartNestedScroll_方法。">Behavior 的 onStartNestedScroll 方法。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Called when a descendant of the CoordinatorLayout attempts to initiate a nested scroll.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Any Behavior associated with any direct child of the CoordinatorLayout may respond</span><br><span class="line"> * to this event and return true to indicate that the CoordinatorLayout should act as</span><br><span class="line"> * a nested scrolling parent for this scroll. Only Behaviors that return true from</span><br><span class="line"> * this method will receive subsequent nested scroll events.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> coordinatorLayout the CoordinatorLayout parent of the view this Behavior is</span><br><span class="line"> *                          associated with</span><br><span class="line"> * <span class="doctag">@param</span> child the child view of the CoordinatorLayout this Behavior is associated with</span><br><span class="line"> * <span class="doctag">@param</span> directTargetChild the child view of the CoordinatorLayout that either is or</span><br><span class="line"> *                          contains the target of the nested scroll operation</span><br><span class="line"> * <span class="doctag">@param</span> target the descendant view of the CoordinatorLayout initiating the nested scroll</span><br><span class="line"> * <span class="doctag">@param</span> nestedScrollAxes the axes that this nested scroll applies to. See</span><br><span class="line"> *                         &#123;<span class="doctag">@link</span> ViewCompat#SCROLL_AXIS_HORIZONTAL&#125;,</span><br><span class="line"> *                         &#123;<span class="doctag">@link</span> ViewCompat#SCROLL_AXIS_VERTICAL&#125;</span><br><span class="line"> * <span class="doctag">@return</span> true if the Behavior wishes to accept this nested scroll</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@see</span> NestedScrollingParent#onStartNestedScroll(View, View, int)</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(CoordinatorLayout coordinatorLayout,</span><br><span class="line">        V child, View directTargetChild, View target, <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法，默认是返回 false ，几个形参容易搞错。</p>
<ol>
<li>child<br>是指 CoordinatorLayout 的直接子 View ，并且是提供这个 Behavior 的 view 。在这个例子中<br>就是指 RecycleView  了。</li>
<li>directTargetChild<br>是指 CoordinatorLayout 的直接子 View ，包含 target 的 view。也就是说，可能是初始引起嵌套<br>滚动的 View 的父 View 。</li>
<li>target<br>是指 CoordinatorLayout 的后代子 View，初始引起嵌套滚动的 View 。</li>
</ol>
<p>回到 NestedScrollingChild 的 startNestedScroll 方法，如果我们返回 true ，那么我们就<br>回进入到方法 ViewParentCompat.onNestedScrollAccepted(p, child, mView, axes) 。<br>根据我们上面对 ViewParentCompat 理解，这个方法最后就是调用 NestedScrollingParent 中，<br>在我们这个例子中，就是进入到 CoordinatorLayout ,那直接看 CoordinatorLayout<br>的 onNestedScrollAccepted 方法。</p>
<h3 id="CoordinatorLayout_的_onNestedScrollAccepted_方法。">CoordinatorLayout 的 onNestedScrollAccepted 方法。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScrollAccepted</span><span class="params">(View child, View target, <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">    mNestedScrollingParentHelper.onNestedScrollAccepted(child, target, nestedScrollAxes);</span><br><span class="line">    mNestedScrollingDirectChild = child;</span><br><span class="line">    mNestedScrollingTarget = target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View view = getChildAt(i);</span><br><span class="line">        <span class="keyword">final</span> LayoutParams lp = (LayoutParams) view.getLayoutParams();</span><br><span class="line">        <span class="keyword">if</span> (!lp.isNestedScrollAccepted()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Behavior viewBehavior = lp.getBehavior();</span><br><span class="line">        <span class="keyword">if</span> (viewBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">            viewBehavior.onNestedScrollAccepted(<span class="keyword">this</span>, view, child, target, nestedScrollAxes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mNestedScrollingParentHelper 记录了 nestedScrollAxes ,然后就遍历所有子 View 的<br>Behavior ，如果这个 Behavior 在先前的方法 onStartNestedScroll 中返回了 false ，就<br>不会得到接下去的执行。如果返回了 true ，就调用 Behavior 的 onNestedScrollAccepted 方法。<br>意思就是，如果一个嵌套滚动被接受了，就会调用这个方法，Behavior 默认没有做任何处理。  </p>
<h3 id="嵌套中的_Down_事件总结">嵌套中的 Down 事件总结</h3><p>在 Down 事件中，touch 事件从 NestedScrollingChild 传递到 NestedScrollingChildHelper<br>, NestedScrollingParent 等，最终会传递 Behavior ，Behavior 需要表态是否接受这个<br>嵌套滚动，如果不接受，那么这个 Behavior 就不会接受这个嵌套滚动的后面 touch 事件了。<br><strong>但是一个 Behavior 不接受嵌套滚动， 并不会阻止这个 touch 事件接下来的分发流程</strong></p>
<h2 id="嵌套中的_MOVE_事件">嵌套中的 MOVE 事件</h2><p>再回到上面的 RecycleView 的 onTouchEvent 源码部分。</p>
<h3 id="RecycleView_的_dispatchNestedPreScroll_方法">RecycleView 的 dispatchNestedPreScroll 方法</h3><p>改方法会在 RecycleView 的 onTouchEvent 方法中调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedPreScroll</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed, <span class="keyword">int</span>[] offsetInWindow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getScrollingChildHelper().dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="NestedScrollingChildHelper_的_dispatchNestedPreScroll_方法">NestedScrollingChildHelper 的 dispatchNestedPreScroll 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * Dispatch one step of a nested pre-scrolling operation to the current nested scrolling parent.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This is a delegate method. Call it from your &#123;<span class="doctag">@link</span> android.view.View View&#125; subclass</span><br><span class="line">     * method/&#123;<span class="doctag">@link</span> NestedScrollingChild&#125; interface method with the same signature to implement</span><br><span class="line">     * the standard policy.&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span> true if the parent consumed any of the nested scroll</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedPreScroll</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed, <span class="keyword">int</span>[] offsetInWindow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isNestedScrollingEnabled() &amp;&amp; mNestedScrollingParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dx != <span class="number">0</span> || dy != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> startX = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> startY = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (offsetInWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mView.getLocationInWindow(offsetInWindow);</span><br><span class="line">                    startX = offsetInWindow[<span class="number">0</span>];</span><br><span class="line">                    startY = offsetInWindow[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (consumed == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mTempNestedScrollConsumed == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mTempNestedScrollConsumed = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    consumed = mTempNestedScrollConsumed;</span><br><span class="line">                &#125;</span><br><span class="line">                consumed[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                consumed[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                ViewParentCompat.onNestedPreScroll(mNestedScrollingParent, mView, dx, dy, consumed);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (offsetInWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mView.getLocationInWindow(offsetInWindow);</span><br><span class="line">                    offsetInWindow[<span class="number">0</span>] -= startX;</span><br><span class="line">                    offsetInWindow[<span class="number">1</span>] -= startY;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> consumed[<span class="number">0</span>] != <span class="number">0</span> || consumed[<span class="number">1</span>] != <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offsetInWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">                offsetInWindow[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                offsetInWindow[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>几个形参的意思</p>
<ol>
<li>consumed<br>代表 NestedScrollingChild 在 NestedPred 过程中，被 NestedScrollingParent<br>(应该说是他的子 View 的 Behavior )消耗了的距离.</li>
<li>offsetInWindow<br>在 NestedPred 流程中， NestedScrollingChild 相对屏幕左上角，位置的更改值。有可能是<br>NestedScrollingChild 在 NestedPred 过程中， NestedScrollingParent 改变了位置，<br>从而导致 NestedScrollingChild 相对屏幕左上角的位置改变了。  </li>
</ol>
<p>再看 ViewParentCompat.onNestedPreScroll 方法。其实就是看 CoordinatorLayout<br>的 onNestedPreScroll 方法了。</p>
<h3 id="CoordinatorLayout_的_onNestedPreScroll_方法了。">CoordinatorLayout 的 onNestedPreScroll 方法了。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedPreScroll</span><span class="params">(View target, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xConsumed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> yConsumed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> accepted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View view = getChildAt(i);</span><br><span class="line">        <span class="keyword">final</span> LayoutParams lp = (LayoutParams) view.getLayoutParams();</span><br><span class="line">        <span class="keyword">if</span> (!lp.isNestedScrollAccepted()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Behavior viewBehavior = lp.getBehavior();</span><br><span class="line">        <span class="keyword">if</span> (viewBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTempIntPair[<span class="number">0</span>] = mTempIntPair[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            viewBehavior.onNestedPreScroll(<span class="keyword">this</span>, view, target, dx, dy, mTempIntPair);</span><br><span class="line"></span><br><span class="line">            xConsumed = dx &gt; <span class="number">0</span> ? Math.max(xConsumed, mTempIntPair[<span class="number">0</span>])</span><br><span class="line">                    : Math.min(xConsumed, mTempIntPair[<span class="number">0</span>]);</span><br><span class="line">            yConsumed = dy &gt; <span class="number">0</span> ? Math.max(yConsumed, mTempIntPair[<span class="number">1</span>])</span><br><span class="line">                    : Math.min(yConsumed, mTempIntPair[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            accepted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    consumed[<span class="number">0</span>] = xConsumed;</span><br><span class="line">    consumed[<span class="number">1</span>] = yConsumed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (accepted) &#123;</span><br><span class="line">        dispatchOnDependentViewChanged(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里可以看到，consumed 的值取所有所有 Behavior 消耗的最极端值（是区分了正负）。<br>这意味着，NestedScrollingChildHelper.dispatchNestedPreScroll 的 consumed<br>是 NestedScrollingParent 的 Behavior 消耗了的。</p>
<h3 id="再看_CoordinatorLayout_的_dispatchOnDependentViewChanged_方法">再看 CoordinatorLayout 的  dispatchOnDependentViewChanged 方法</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * Dispatch any dependent view changes to the relevant &#123;<span class="doctag">@link</span> Behavior&#125; instances.</span><br><span class="line">     *</span><br><span class="line">     * Usually run as part of the pre-draw step when at least one child view has a reported</span><br><span class="line">     * dependency on another view. This allows CoordinatorLayout to account for layout</span><br><span class="line">     * changes and animations that occur outside of the normal layout pass.</span><br><span class="line">     *</span><br><span class="line">     * It can also be ran as part of the nested scrolling dispatch to ensure that any offsetting</span><br><span class="line">     * is completed within the correct coordinate window.</span><br><span class="line">     *</span><br><span class="line">     * The offsetting behavior implemented here does not store the computed offset in</span><br><span class="line">     * the LayoutParams; instead it expects that the layout process will always reconstruct</span><br><span class="line">     * the proper positioning.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> fromNestedScroll true if this is being called from one of the nested scroll methods,</span><br><span class="line">     *                         false if run as part of the pre-draw step.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispatchOnDependentViewChanged</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> fromNestedScroll)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = ViewCompat.getLayoutDirection(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = mDependencySortedChildren.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = mDependencySortedChildren.get(i);</span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check child views before for anchor</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">final</span> View checkChild = mDependencySortedChildren.get(j);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (lp.mAnchorDirectChild == checkChild) &#123;</span><br><span class="line">                    offsetChildToAnchor(child, layoutDirection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Did it change? if not continue</span></span><br><span class="line">            <span class="keyword">final</span> Rect oldRect = mTempRect1;</span><br><span class="line">            <span class="keyword">final</span> Rect newRect = mTempRect2;</span><br><span class="line">            getLastChildRect(child, oldRect);</span><br><span class="line">            getChildRect(child, <span class="keyword">true</span>, newRect);</span><br><span class="line">            <span class="keyword">if</span> (oldRect.equals(newRect)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            recordLastChildRect(child, newRect);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Update any behavior-dependent views for the change</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; childCount; j++) &#123;</span><br><span class="line">                <span class="keyword">final</span> View checkChild = mDependencySortedChildren.get(j);</span><br><span class="line">                <span class="keyword">final</span> LayoutParams checkLp = (LayoutParams) checkChild.getLayoutParams();</span><br><span class="line">                <span class="keyword">final</span> Behavior b = checkLp.getBehavior();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (b != <span class="keyword">null</span> &amp;&amp; b.layoutDependsOn(<span class="keyword">this</span>, checkChild, child)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!fromNestedScroll &amp;&amp; checkLp.getChangedAfterNestedScroll()) &#123;</span><br><span class="line">                        <span class="comment">// If this is not from a nested scroll and we have already been changed</span></span><br><span class="line">                        <span class="comment">// from a nested scroll, skip the dispatch and reset the flag</span></span><br><span class="line">                        checkLp.resetChangedAfterNestedScroll();</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> handled = b.onDependentViewChanged(<span class="keyword">this</span>, checkChild, child);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (fromNestedScroll) &#123;</span><br><span class="line">                        <span class="comment">// If this is from a nested scroll, set the flag so that we may skip</span></span><br><span class="line">                        <span class="comment">// any resulting onPreDraw dispatch (if needed)</span></span><br><span class="line">                        checkLp.setChangedAfterNestedScroll(handled);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 这里可能会调用 Behavior 的2个方法<br> layoutDependsOn 和 onDependentViewChanged 方法。</p>
<h3 id="Behavior_的_layoutDependsOn_方法">Behavior 的 layoutDependsOn 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Determine whether the supplied child view has another specific sibling view as a</span><br><span class="line"> * layout dependency.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This method will be called at least once in response to a layout request. If it</span><br><span class="line"> * returns true for a given child and dependency view pair, the parent CoordinatorLayout</span><br><span class="line"> * will:&lt;/p&gt;</span><br><span class="line"> * &lt;ol&gt;</span><br><span class="line"> *     &lt;li&gt;Always lay out this child after the dependent child is laid out, regardless</span><br><span class="line"> *     of child order.&lt;/li&gt;</span><br><span class="line"> *     &lt;li&gt;Call &#123;<span class="doctag">@link</span> #onDependentViewChanged&#125; when the dependency view's layout or</span><br><span class="line"> *     position changes.&lt;/li&gt;</span><br><span class="line"> * &lt;/ol&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> parent the parent view of the given child</span><br><span class="line"> * <span class="doctag">@param</span> child the child view to test</span><br><span class="line"> * <span class="doctag">@param</span> dependency the proposed dependency of child</span><br><span class="line"> * <span class="doctag">@return</span> true if child's layout depends on the proposed dependency's layout,</span><br><span class="line"> *         false otherwise</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@see</span> #onDependentViewChanged(CoordinatorLayout, android.view.View, android.view.View)</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">layoutDependsOn</span><span class="params">(CoordinatorLayout parent, V child, View dependency)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>形参的含义<br> 询问 child 到底是否依赖 dependency 。如果返回 true ， CoordinatorLayout 会在<br> lay out 完 dependency 之后，不管 child 顺序，就 lay out 这个形参 child 了。</p>
<h3 id="Behavior_的_onDependentViewChanged_方法">Behavior 的 onDependentViewChanged 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Respond to a change in a child's dependent view</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This method is called whenever a dependent view changes in size or position outside</span><br><span class="line"> * of the standard layout flow. A Behavior may use this method to appropriately update</span><br><span class="line"> * the child view in response.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;A view's dependency is determined by</span><br><span class="line"> * &#123;<span class="doctag">@link</span> #layoutDependsOn(CoordinatorLayout, android.view.View, android.view.View)&#125; or</span><br><span class="line"> * if &#123;<span class="doctag">@code</span> child&#125; has set another view as it's anchor.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Note that if a Behavior changes the layout of a child via this method, it should</span><br><span class="line"> * also be able to reconstruct the correct position in</span><br><span class="line"> * &#123;<span class="doctag">@link</span> #onLayoutChild(CoordinatorLayout, android.view.View, int) onLayoutChild&#125;.</span><br><span class="line"> * &lt;code&gt;onDependentViewChanged&lt;/code&gt; will not be called during normal layout since</span><br><span class="line"> * the layout of each child view will always happen in dependency order.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;If the Behavior changes the child view's size or position, it should return true.</span><br><span class="line"> * The default implementation returns false.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> parent the parent view of the given child</span><br><span class="line"> * <span class="doctag">@param</span> child the child view to manipulate</span><br><span class="line"> * <span class="doctag">@param</span> dependency the dependent view that changed</span><br><span class="line"> * <span class="doctag">@return</span> true if the Behavior changed the child view's size or position, false otherwise</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDependentViewChanged</span><span class="params">(CoordinatorLayout parent, V child, View dependency)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当 dependency 改变了位置或者大小的时候，都会触发此方法，这个方法是一个恰当的时机去改变<br>形参中的 child view 。如果在这个方法里面改变了 child 的位置或者大小，必须可以在<br>CoordinatorLayout 的 onLayoutChild 中可以复原。<strong>undo 意味着，改变 left top 没效咯？</strong><br><strong>mark</strong><br>在 Behavior 的方法 onLayoutChild 注解中可以看到，实现了 onDependentViewChanged<br>，那么也应该实现 onLayoutChild 方法。<br>如果改变了 child ，该方法就应该返回  true 。</p>
<h3 id="嵌套的_Move_事件中的_NestedPre_过程小结">嵌套的 Move 事件中的 NestedPre 过程小结</h3><p>由 NestedScrollingChild.dispatchNestedPreScroll 发起，最后给到<br>NestedScrollingParent 的 Behavior 来消费。  </p>
<ol>
<li>需要注意的是，在 NestedScrollingChild 中，需要对 Behavior 消费的距离，<br>以及因为 NestedScrollingParent 改变位置，导致 NestedScrollingChild<br>相对屏幕左上角坐标的改变，做相应的调整。  </li>
<li>layoutDependsOn 返回 true 的话，会接着调用 onDependentViewChanged ，此方法<br>是一个比较恰当的时机去改变 child ，但是需要注意需要保证在 CoordinatorLayout  的<br>onLayoutChild 方法中可以复原。</li>
</ol>
<h3 id="再回到_RecycleView_的_onTouchEvent_和_scrollByInternal_方法">再回到 RecycleView 的 onTouchEvent 和 scrollByInternal 方法</h3><p>可以看到调用了 RecycleView 的 scrollByInternal 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * Does not perform bounds checking. Used by internal methods that have already validated input.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * It also reports any unused scroll request to the related EdgeEffect.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> x The amount of horizontal scroll request</span><br><span class="line">     * <span class="doctag">@param</span> y The amount of vertical scroll request</span><br><span class="line">     * <span class="doctag">@param</span> ev The originating MotionEvent, or null if not from a touch event.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span> Whether any scroll was consumed in either direction.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">scrollByInternal</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> unconsumedX = <span class="number">0</span>, unconsumedY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> consumedX = <span class="number">0</span>, consumedY = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        consumePendingUpdateOperations();</span><br><span class="line">        <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            eatRequestLayout();</span><br><span class="line">            onEnterLayoutOrScroll();</span><br><span class="line">            TraceCompat.beginSection(TRACE_SCROLL_TAG);</span><br><span class="line">            <span class="keyword">if</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">                consumedX = mLayout.scrollHorizontallyBy(x, mRecycler, mState);</span><br><span class="line">                unconsumedX = x - consumedX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (y != <span class="number">0</span>) &#123;</span><br><span class="line">                consumedY = mLayout.scrollVerticallyBy(y, mRecycler, mState);</span><br><span class="line">                unconsumedY = y - consumedY;</span><br><span class="line">            &#125;</span><br><span class="line">            TraceCompat.endSection();</span><br><span class="line">            repositionShadowingViews();</span><br><span class="line">            onExitLayoutOrScroll();</span><br><span class="line">            resumeRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!mItemDecorations.isEmpty()) &#123;</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dispatchNestedScroll(consumedX, consumedY, unconsumedX, unconsumedY, mScrollOffset)) &#123;</span><br><span class="line">            <span class="comment">// Update the last touch co-ords, taking any scroll offset into account</span></span><br><span class="line">            mLastTouchX -= mScrollOffset[<span class="number">0</span>];</span><br><span class="line">            mLastTouchY -= mScrollOffset[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (ev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ev.offsetLocation(mScrollOffset[<span class="number">0</span>], mScrollOffset[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            mNestedOffsets[<span class="number">0</span>] += mScrollOffset[<span class="number">0</span>];</span><br><span class="line">            mNestedOffsets[<span class="number">1</span>] += mScrollOffset[<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ViewCompat.getOverScrollMode(<span class="keyword">this</span>) != ViewCompat.OVER_SCROLL_NEVER) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pullGlows(ev.getX(), unconsumedX, ev.getY(), unconsumedY);</span><br><span class="line">            &#125;</span><br><span class="line">            considerReleasingGlowsOnScroll(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (consumedX != <span class="number">0</span> || consumedY != <span class="number">0</span>) &#123;</span><br><span class="line">            dispatchOnScrolled(consumedX, consumedY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!awakenScrollBars()) &#123;</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> consumedX != <span class="number">0</span> || consumedY != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>和嵌套滚动相关的，就是调用了 dispatchNestedScroll ，这个方法里面，实际就是调用了<br>NestedScrollingChild 的 dispatchNestedScroll 方法。</p>
<h3 id="NestedScrollingChild_的_dispatchNestedScroll_方法。">NestedScrollingChild 的 dispatchNestedScroll 方法。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * Dispatch one step of a nested scrolling operation to the current nested scrolling parent.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This is a delegate method. Call it from your &#123;<span class="doctag">@link</span> android.view.View View&#125; subclass</span><br><span class="line">     * method/&#123;<span class="doctag">@link</span> NestedScrollingChild&#125; interface method with the same signature to implement</span><br><span class="line">     * the standard policy.&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span> true if the parent consumed any of the nested scroll</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedScroll</span><span class="params">(<span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed,</span><br><span class="line">            <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed, <span class="keyword">int</span>[] offsetInWindow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isNestedScrollingEnabled() &amp;&amp; mNestedScrollingParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dxConsumed != <span class="number">0</span> || dyConsumed != <span class="number">0</span> || dxUnconsumed != <span class="number">0</span> || dyUnconsumed != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> startX = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> startY = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (offsetInWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mView.getLocationInWindow(offsetInWindow);</span><br><span class="line">                    startX = offsetInWindow[<span class="number">0</span>];</span><br><span class="line">                    startY = offsetInWindow[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ViewParentCompat.onNestedScroll(mNestedScrollingParent, mView, dxConsumed,</span><br><span class="line">                        dyConsumed, dxUnconsumed, dyUnconsumed);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (offsetInWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mView.getLocationInWindow(offsetInWindow);</span><br><span class="line">                    offsetInWindow[<span class="number">0</span>] -= startX;</span><br><span class="line">                    offsetInWindow[<span class="number">1</span>] -= startY;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offsetInWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No motion, no dispatch. Keep offsetInWindow up to date.</span></span><br><span class="line">                offsetInWindow[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                offsetInWindow[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里，又算了下，让 NestedScrollingParent 的位置改变，导致 NestedScrollingChild<br>相对屏幕左上角的改变。用 offsetInWindow 记录了。 NestedScrollingChild 可能需要对<br>这个做相应的处理。中间调用的 ViewParentCompat.onNestedScroll 实际就是调用的<br>CoordinatorLayout 的 onNestedScroll</p>
<h3 id="CoordinatorLayout_的_onNestedScroll">CoordinatorLayout 的 onNestedScroll</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(View target, <span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed,</span><br><span class="line">            <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">        <span class="keyword">boolean</span> accepted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View view = getChildAt(i);</span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) view.getLayoutParams();</span><br><span class="line">            <span class="keyword">if</span> (!lp.isNestedScrollAccepted()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Behavior viewBehavior = lp.getBehavior();</span><br><span class="line">            <span class="keyword">if</span> (viewBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">                viewBehavior.onNestedScroll(<span class="keyword">this</span>, view, target, dxConsumed, dyConsumed,</span><br><span class="line">                        dxUnconsumed, dyUnconsumed);</span><br><span class="line">                accepted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (accepted) &#123;</span><br><span class="line">            dispatchOnDependentViewChanged(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其实都是给 Behavior 来处理了。</p>
<h3 id="嵌套滚动中_MOVE_事件整体小结">嵌套滚动中 MOVE 事件整体小结</h3><p>在 NestedPre 中，NestedScrollingChild 告诉 NestedScrollingParent 有多少滚动距离，<br>NestedScrollingParent 把滚动都给 Behavior 的 onNestedPreScroll 来处理，消费了多少，<br>需要记录下来，并告诉 NestedScrollingParent .这个 NestedScrollingParent 的 Behavior<br>消耗了多少，告诉 NestedScrollingChild 使用的方式是， NestedScrollingChild 传递<br>一个引用给 NestedScrollingParent ，NestedScrollingParent 再修改这个引用指向的对象<br>部分的属性.  </p>
<p>在 Nested 中，NestedScrollingChild 自己消费一部分，告诉 NestedScrollingParent<br>自己消费了多少，没有消费的还有多少，NestedScrollingParent 再全部告诉 Behavior 。  </p>
<p><strong>标准的做法就是</strong></p>
<ul>
<li>自己先不消耗滚动距离，让 NestedScrollingParent 的 onNestedPreScroll<br>方法优先消费滚动距离。然后 中，NestedScrollingChild 记录一下这个过程中消费的距离。</li>
<li>中，NestedScrollingChild 自己消耗一下滚动距离.</li>
<li>然后 中，NestedScrollingChild 把已经消费了的，和未消费的，给到 NestedScrollingParent<br>的方法 onNestedScroll 。</li>
</ul>
<h2 id="嵌套中的_UP_事件">嵌套中的 UP 事件</h2><p>这个就比较简单了，就是调用 NestedScrollingChild 的 stopNestedScroll ，接着<br>NestedScrollingChildHelper  的 stopNestedScroll ，最后就是<br>NestedScrollingParent 的 Behavior 的 stopNestedScroll 了。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/12/CoordinatorLayout-源码学习/" itemprop="url">
                  CoordinatorLayout 源码学习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-06-12T10:56:19+08:00" content="2016-06-12">
              2016-06-12
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>源码版本号<br>design : 23.3.0</p>
<h2 id="触摸事件分发">触摸事件分发</h2><p>并没有重载 dispatchTouchEvent 方法，仅仅重载了 onInterceptTouchEvent 和<br>onTouchEvent 方法。</p>
<h3 id="onInterceptTouchEvent_方法">onInterceptTouchEvent 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        MotionEvent cancelEvent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure we reset in case we had missed a previous important event.</span></span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            resetTouchBehaviors();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> intercepted = performIntercept(ev, TYPE_ON_INTERCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cancelEvent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cancelEvent.recycle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">            resetTouchBehaviors();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> intercepted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这个方法体内，如果检测到时 DOWN 或者 UP 或者 CANCEL 事件，都会调用方法<br>resetTouchBehaviors ，尝试让恢复到初始状态。 onInterceptTouchEvent 方法返回值取方法<br>performIntercept 的返回值。<br>接下来，跟踪下方法 resetTouchBehaviors 和 performIntercept 。</p>
<h3 id="resetTouchBehaviors_方法">resetTouchBehaviors 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * Reset all Behavior-related tracking records either to clean up or in preparation</span><br><span class="line">     * for a new event stream. This should be called when attached or detached from a window,</span><br><span class="line">     * in response to an UP or CANCEL event, when intercept is request-disallowed</span><br><span class="line">     * and similar cases where an event stream in progress will be aborted.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resetTouchBehaviors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mBehaviorTouchView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Behavior b = ((LayoutParams) mBehaviorTouchView.getLayoutParams()).getBehavior();</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                <span class="keyword">final</span> MotionEvent cancelEvent = MotionEvent.obtain(now, now,</span><br><span class="line">                        MotionEvent.ACTION_CANCEL, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0</span>);</span><br><span class="line">                b.onTouchEvent(<span class="keyword">this</span>, mBehaviorTouchView, cancelEvent);</span><br><span class="line">                cancelEvent.recycle();</span><br><span class="line">            &#125;</span><br><span class="line">            mBehaviorTouchView = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">            lp.resetTouchBehaviorTracking();</span><br><span class="line">        &#125;</span><br><span class="line">        mDisallowInterceptReset = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>重置 touch 状态。这方法体内，做的事情是，发送一个 cancelEvent 给 Behavior 。并且<br>把 mBehaviorTouchView 置空。并且遍历所有子 View ，调用子 View 的<br>LayoutParams.resetTouchBehaviorTracking(). 改方法做的事情，就是把标志位改为 false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Reset tracking of Behavior-specific touch interactions. This includes</span><br><span class="line"> * interaction blocking.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@see</span> #isBlockingInteractionBelow(CoordinatorLayout, android.view.View)</span><br><span class="line"> * <span class="doctag">@see</span> #didBlockInteraction()</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resetTouchBehaviorTracking</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDidBlockInteraction = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="performIntercept_方法">performIntercept 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">performIntercept</span><span class="params">(MotionEvent ev, <span class="keyword">final</span> <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> intercepted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> newBlock = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        MotionEvent cancelEvent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> List&lt;View&gt; topmostChildList = mTempList1;</span><br><span class="line">        getTopSortedChildren(topmostChildList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Let topmost child views inspect first</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = topmostChildList.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = topmostChildList.get(i);</span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">            <span class="keyword">final</span> Behavior b = lp.getBehavior();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((intercepted || newBlock) &amp;&amp; action != MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">                <span class="comment">// Cancel all behaviors beneath the one that intercepted.</span></span><br><span class="line">                <span class="comment">// If the event is "down" then we don't have anything to cancel yet.</span></span><br><span class="line">                <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cancelEvent == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                        cancelEvent = MotionEvent.obtain(now, now,</span><br><span class="line">                                MotionEvent.ACTION_CANCEL, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">                        <span class="keyword">case</span> TYPE_ON_INTERCEPT:</span><br><span class="line">                            b.onInterceptTouchEvent(<span class="keyword">this</span>, child, cancelEvent);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> TYPE_ON_TOUCH:</span><br><span class="line">                            b.onTouchEvent(<span class="keyword">this</span>, child, cancelEvent);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!intercepted &amp;&amp; b != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">                    <span class="keyword">case</span> TYPE_ON_INTERCEPT:</span><br><span class="line">                        intercepted = b.onInterceptTouchEvent(<span class="keyword">this</span>, child, ev);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> TYPE_ON_TOUCH:</span><br><span class="line">                        intercepted = b.onTouchEvent(<span class="keyword">this</span>, child, ev);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (intercepted) &#123;</span><br><span class="line">                    mBehaviorTouchView = child;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Don't keep going if we're not allowing interaction below this.</span></span><br><span class="line">            <span class="comment">// Setting newBlock will make sure we cancel the rest of the behaviors.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> wasBlocking = lp.didBlockInteraction();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> isBlocking = lp.isBlockingInteractionBelow(<span class="keyword">this</span>, child);</span><br><span class="line">            newBlock = isBlocking &amp;&amp; !wasBlocking;</span><br><span class="line">            <span class="keyword">if</span> (isBlocking &amp;&amp; !newBlock) &#123;</span><br><span class="line">                <span class="comment">// Stop here since we don't have anything more to cancel - we already did</span></span><br><span class="line">                <span class="comment">// when the behavior first started blocking things below this point.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        topmostChildList.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> intercepted;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法体内，做了如下</p>
<ol>
<li>首先将所有子 View ，根据 Z 轴排序。然后根据这个排序，遍历所有子 View ，  </li>
<li>如果发现这个 event 事件，已经被拦截，或者被阻塞了，就发送一个 cancelEvent 给子 View<br>的 Behavior 。</li>
<li>如果这个 event 事件，还没有被拦截并且子 View 的 Behavior 不为空，就把这个 event 交给<br>该子 View 的 Behavior 来处理。至于调用 Behavior 的 onInterceptTouchEvent 方法，还是<br>onTouchEvent 方法，取决于，这个方法的入参 type 了。</li>
<li>如果有子 View 拦截了（即 intercepted == true），则把该子 View 赋值给<br>mBehaviorTouchView .</li>
<li>检查下，是否正在阻塞或者新的阻塞，并且做了一些处理。</li>
</ol>
<h3 id="onTouchEvent_方法">onTouchEvent 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> cancelSuper = <span class="keyword">false</span>;</span><br><span class="line">        MotionEvent cancelEvent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(ev);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mBehaviorTouchView != <span class="keyword">null</span> || (cancelSuper = performIntercept(ev, TYPE_ON_TOUCH))) &#123;</span><br><span class="line">            <span class="comment">// Safe since performIntercept guarantees that</span></span><br><span class="line">            <span class="comment">// mBehaviorTouchView != null if it returns true</span></span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) mBehaviorTouchView.getLayoutParams();</span><br><span class="line">            <span class="keyword">final</span> Behavior b = lp.getBehavior();</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">                handled = b.onTouchEvent(<span class="keyword">this</span>, mBehaviorTouchView, ev);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Keep the super implementation correct</span></span><br><span class="line">        <span class="keyword">if</span> (mBehaviorTouchView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            handled |= <span class="keyword">super</span>.onTouchEvent(ev);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cancelSuper) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cancelEvent == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                cancelEvent = MotionEvent.obtain(now, now,</span><br><span class="line">                        MotionEvent.ACTION_CANCEL, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">super</span>.onTouchEvent(cancelEvent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!handled &amp;&amp; action == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cancelEvent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cancelEvent.recycle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">            resetTouchBehaviors();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法体内，做了如下事情</p>
<ol>
<li>如果 mBehaviorTouchView 不为空，就把这个事件，交给 mBehaviorTouchView 的<br>LayoutParams 的 Behavior 的方法 onTouchEvent 来处理。并取返回值，赋值给 handled 。  </li>
<li>如果 mBehaviorTouchView 为空，则把这个事件交给 CoordinatorLayout 的父类来处理。<br>直接调用的 handled |= super.onTouchEvent(ev);</li>
<li>如果 cancelSuper  == true （cancelSuper 是取 performIntercept 的返回值的），<br>那么就制造一个 cancelEvent 给 CoordinatorLayout 的父类来处理。<br>super.onTouchEvent(cancelEvent).</li>
<li>如果是 UP 或者 CANCEL 事件，就调用 resetTouchBehaviors 方法</li>
<li>整个方法，返回值取  handled .</li>
</ol>
<h2 id="一些方法作用简介">一些方法作用简介</h2><p>记录一些方法的作用</p>
<ol>
<li>parseBehavior</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Behavior <span class="title">parseBehavior</span><span class="params">(Context context, AttributeSet attrs, String name)</span> </span>&#123;</span><br><span class="line">..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据 name 来构造一个 Behavior</p>
<ol>
<li>getResolvedLayoutParams</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LayoutParams <span class="title">getResolvedLayoutParams</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据这个 child 来找到这个 child 类的 DefaultBehavior 。并且赋值给 这个 child 的<br>CoordinatorLayout.LayoutParams<br>result.setBehavior(defaultBehavior.value().newInstance());</p>
<ol>
<li>prepareChildren</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历所有子 View ，准备好 LayoutParams 并且找好 AnchorView 。并且按照约定，排序好。<br>mDependencySortedChildren</p>
<ol>
<li>dispatchOnDependentViewChanged</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span><br><span class="line">       * Dispatch any dependent view changes to the relevant &#123;<span class="doctag">@link</span> Behavior&#125; instances.</span><br><span class="line">       *</span><br><span class="line">       * Usually run as part of the pre-draw step when at least one child view has a reported</span><br><span class="line">       * dependency on another view. This allows CoordinatorLayout to account for layout</span><br><span class="line">       * changes and animations that occur outside of the normal layout pass.</span><br><span class="line">       *</span><br><span class="line">       * It can also be ran as part of the nested scrolling dispatch to ensure that any offsetting</span><br><span class="line">       * is completed within the correct coordinate window.</span><br><span class="line">       *</span><br><span class="line">       * The offsetting behavior implemented here does not store the computed offset in</span><br><span class="line">       * the LayoutParams; instead it expects that the layout process will always reconstruct</span><br><span class="line">       * the proper positioning.</span><br><span class="line">       *</span><br><span class="line">       * <span class="doctag">@param</span> fromNestedScroll true if this is being called from one of the nested scroll methods,</span><br><span class="line">       *                         false if run as part of the pre-draw step.</span><br><span class="line">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">dispatchOnDependentViewChanged</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> fromNestedScroll)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = ViewCompat.getLayoutDirection(<span class="keyword">this</span>);</span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">int</span> childCount = mDependencySortedChildren.size();</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">              <span class="keyword">final</span> View child = mDependencySortedChildren.get(i);</span><br><span class="line">              <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">              <span class="comment">// Check child views before for anchor</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                  <span class="keyword">final</span> View checkChild = mDependencySortedChildren.get(j);</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span> (lp.mAnchorDirectChild == checkChild) &#123;</span><br><span class="line">                      offsetChildToAnchor(child, layoutDirection);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">// Did it change? if not continue</span></span><br><span class="line">              <span class="keyword">final</span> Rect oldRect = mTempRect1;</span><br><span class="line">              <span class="keyword">final</span> Rect newRect = mTempRect2;</span><br><span class="line">              getLastChildRect(child, oldRect);</span><br><span class="line">              getChildRect(child, <span class="keyword">true</span>, newRect);</span><br><span class="line">              <span class="keyword">if</span> (oldRect.equals(newRect)) &#123;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              recordLastChildRect(child, newRect);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// Update any behavior-dependent views for the change</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; childCount; j++) &#123;</span><br><span class="line">                  <span class="keyword">final</span> View checkChild = mDependencySortedChildren.get(j);</span><br><span class="line">                  <span class="keyword">final</span> LayoutParams checkLp = (LayoutParams) checkChild.getLayoutParams();</span><br><span class="line">                  <span class="keyword">final</span> Behavior b = checkLp.getBehavior();</span><br><span class="line"></span><br><span class="line">                  <span class="keyword">if</span> (b != <span class="keyword">null</span> &amp;&amp; b.layoutDependsOn(<span class="keyword">this</span>, checkChild, child)) &#123;</span><br><span class="line">                      <span class="keyword">if</span> (!fromNestedScroll &amp;&amp; checkLp.getChangedAfterNestedScroll()) &#123;</span><br><span class="line">                          <span class="comment">// If this is not from a nested scroll and we have already been changed</span></span><br><span class="line">                          <span class="comment">// from a nested scroll, skip the dispatch and reset the flag</span></span><br><span class="line">                          checkLp.resetChangedAfterNestedScroll();</span><br><span class="line">                          <span class="keyword">continue</span>;</span><br><span class="line">                      &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">final</span> <span class="keyword">boolean</span> handled = b.onDependentViewChanged(<span class="keyword">this</span>, checkChild, child);</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> (fromNestedScroll) &#123;</span><br><span class="line">                          <span class="comment">// If this is from a nested scroll, set the flag so that we may skip</span></span><br><span class="line">                          <span class="comment">// any resulting onPreDraw dispatch (if needed)</span></span><br><span class="line">                          checkLp.setChangedAfterNestedScroll(handled);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Behavior_相关">Behavior 相关</h2><p>Behavior 的对象，其实是存在于 CoordinatorLayout 的 LayoutParams 上的，是 LayoutParams<br>的一个成员变量。因此，这个 Behavior 仅仅存在于 CoordinatorLayout 的直接子类中，才<br>会有所作用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Parameters describing the desired layout for a child of a &#123;<span class="doctag">@link</span> CoordinatorLayout&#125;.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutParams</span> <span class="keyword">extends</span> <span class="title">ViewGroup</span>.<span class="title">MarginLayoutParams</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * A &#123;<span class="doctag">@link</span> Behavior&#125; that the child view should obey.</span><br><span class="line">     */</span></span><br><span class="line">    Behavior mBehavior;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Behavior_的设置方法">Behavior 的设置方法</h3><p>Behavior 的设置方式有2种。注解方式和在 XML 中直接指定。他们不仅在使用上有点区别，在<br>Behavior 的具体生成时机，也是有点不一样的。</p>
<h4 id="注解方式">注解方式</h4><p>我们可以看看 AppBarLayout 学习一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@CoordinatorLayout</span>.DefaultBehavior(AppBarLayout.Behavior.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppBarLayout</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> </span>&#123;</span><br><span class="line">..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式，Behavior 的确立生成时机是:</p>
<p>getResolvedLayoutParams -&gt; prepareChildren -&gt;  onMeasure</p>
<p>先看看 getResolvedLayoutParams 方法的实现原理：涉及到的逻辑有，看看是否已经添加<br>Behavior ，查看这个 view child 的注解，是否包含 DefaultBehavior 。如果没有就找这个<br>view child 的父类。由此可见，我们可以给一个通用的 View 添加一个默认的 DefaultBehavior<br>，如果有更深层的自定义需求，就可以继承这个通用 view 来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LayoutParams <span class="title">getResolvedLayoutParams</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> LayoutParams result = (LayoutParams) child.getLayoutParams();</span><br><span class="line">        <span class="keyword">if</span> (!result.mBehaviorResolved) &#123;</span><br><span class="line">            Class&lt;?&gt; childClass = child.getClass();</span><br><span class="line">            DefaultBehavior defaultBehavior = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (childClass != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    (defaultBehavior = childClass.getAnnotation(DefaultBehavior.class)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                childClass = childClass.getSuperclass();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (defaultBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    result.setBehavior(defaultBehavior.value().newInstance());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    Log.e(TAG, <span class="string">"Default behavior class "</span> + defaultBehavior.value().getName() +</span><br><span class="line">                            <span class="string">" could not be instantiated. Did you forget a default constructor?"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.mBehaviorResolved = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>再看看 prepareChildren 方法，实现原理。就是遍历所有子 View ，尝试找到 Behavior 并且<br>生成一个实例，并绑定到自己身上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mDependencySortedChildren.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, count = getChildCount(); i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = getResolvedLayoutParams(child);</span><br><span class="line">            lp.findAnchorView(<span class="keyword">this</span>, child);</span><br><span class="line"></span><br><span class="line">            mDependencySortedChildren.add(child);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We need to use a selection sort here to make sure that every item is compared</span></span><br><span class="line">        <span class="comment">// against each other</span></span><br><span class="line">        selectionSort(mDependencySortedChildren, mLayoutDependencyComparator);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="在_XML_中直接指定">在 XML 中直接指定</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.v4.view.ViewPager</span><br><span class="line">              android:id=<span class="string">"@+id/viewpager"</span></span><br><span class="line">              android:layout_width=<span class="string">"match_parent"</span></span><br><span class="line">              android:layout_height=<span class="string">"match_parent"</span></span><br><span class="line">              app:layout_behavior=<span class="string">"@string/appbar_scrolling_view_behavior"</span></span><br><span class="line">              /&gt;</span><br></pre></td></tr></table></figure>
<p>Behavior  生成时机是：在 inflate 流程中，我们可以知道，子 View 的 LayoutParams<br>是由父 View的 generateLayoutParams 方法提供的。而 Behavior 又是<br>CoordinatorLayout.LayoutParams 的成员变量，很自然的，可以死追索到如下生成链<br>generateLayoutParams -&gt; LayoutParams 的 构造方法 -&gt; parseBehavior<br>来看看 parseBehavior 的源码实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Behavior <span class="title">parseBehavior</span><span class="params">(Context context, AttributeSet attrs, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String fullName;</span><br><span class="line">        <span class="keyword">if</span> (name.startsWith(<span class="string">"."</span>)) &#123;</span><br><span class="line">            <span class="comment">// Relative to the app package. Prepend the app package name.</span></span><br><span class="line">            fullName = context.getPackageName() + name;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.indexOf(<span class="string">'.'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Fully qualified package name.</span></span><br><span class="line">            fullName = name;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Assume stock behavior in this package (if we have one)</span></span><br><span class="line">            fullName = !TextUtils.isEmpty(WIDGET_PACKAGE_NAME)</span><br><span class="line">                    ? (WIDGET_PACKAGE_NAME + <span class="string">'.'</span> + name)</span><br><span class="line">                    : name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Map&lt;String, Constructor&lt;Behavior&gt;&gt; constructors = sConstructors.get();</span><br><span class="line">            <span class="keyword">if</span> (constructors == <span class="keyword">null</span>) &#123;</span><br><span class="line">                constructors = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                sConstructors.set(constructors);</span><br><span class="line">            &#125;</span><br><span class="line">            Constructor&lt;Behavior&gt; c = constructors.get(fullName);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> Class&lt;Behavior&gt; clazz = (Class&lt;Behavior&gt;) Class.forName(fullName, <span class="keyword">true</span>,</span><br><span class="line">                        context.getClassLoader());</span><br><span class="line">                c = clazz.getConstructor(CONSTRUCTOR_PARAMS);</span><br><span class="line">                c.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                constructors.put(fullName, c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c.newInstance(context, attrs);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Could not inflate Behavior subclass "</span> + fullName, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="CoordinatorLayout_绘制流程">CoordinatorLayout 绘制流程</h2><p>CoordinatorLayout  重写了，onMeasure onLayout onDraw 这几个流程。</p>
<h3 id="onMeasure_on_CoordinatorLayout_方法">onMeasure on CoordinatorLayout 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prepareChildren();</span><br><span class="line">        ensurePreDrawListener();</span><br></pre></td></tr></table></figure>
<p>先调用上面2个方法，为下面做准备。<br>大致流程就是，遍历所有子 View ，如果子 View 的 Behavior 不为空，就交给 Behavior 处理，<br>如果 Behavior 消费了对这个子 View 的 measure 流程，则 CoordinatorLayout 就不再对此<br>子 View 进行 measure 了。<br>关键代码如下  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (b == <span class="keyword">null</span> || !b.onMeasureChild(<span class="keyword">this</span>, child, childWidthMeasureSpec, keylineWidthUsed,</span><br><span class="line">                    childHeightMeasureSpec, <span class="number">0</span>)) &#123;</span><br><span class="line">                onMeasureChild(child, childWidthMeasureSpec, keylineWidthUsed,</span><br><span class="line">                        childHeightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<h3 id="onLayout_on_CoordinatorLayout_方法">onLayout on CoordinatorLayout 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = ViewCompat.getLayoutDirection(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = mDependencySortedChildren.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = mDependencySortedChildren.get(i);</span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">            <span class="keyword">final</span> Behavior behavior = lp.getBehavior();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (behavior == <span class="keyword">null</span> || !behavior.onLayoutChild(<span class="keyword">this</span>, child, layoutDirection)) &#123;</span><br><span class="line">                onLayoutChild(child, layoutDirection);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>简单理解的话，就是 如果 Behavior 不为空，并且消费了这个 layout 过程的话，就不处理了。否则就<br>交给自己处理。</p>
<h3 id="onDraw_on_CoordinatorLayout_方法">onDraw on CoordinatorLayout 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDraw(c);</span><br><span class="line">        <span class="keyword">if</span> (mDrawStatusBarBackground &amp;&amp; mStatusBarBackground != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> inset = mLastInsets != <span class="keyword">null</span> ? mLastInsets.getSystemWindowInsetTop() : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (inset &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                mStatusBarBackground.setBounds(<span class="number">0</span>, <span class="number">0</span>, getWidth(), inset);</span><br><span class="line">                mStatusBarBackground.draw(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>特别绘制了，状态栏的背景。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/14/常用设计模式/" itemprop="url">
                  常用设计模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-05-14T11:37:28+08:00" content="2016-05-14">
              2016-05-14
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h1 id="设计原则">设计原则</h1><ol>
<li>依赖倒转<br>依赖抽象，不依赖具体。<br>在工厂方法中，就体现了这一点， creator 中的公共主体逻辑可以先写好，写个抽象方法来延迟实现，<br>让子类是具体实现。在 Volley 中的 http client 就体现了这一点。它会根据 SDK level 来<br>采取不同的实现。<h1 id="常见设计模式">常见设计模式</h1></li>
<li>工厂模式<br>分为，简单工厂、抽象工厂和工厂方法，一共3种。</li>
<li>外观模式</li>
<li>适配者模式</li>
<li>工厂方法模式</li>
<li>抽象工厂方法</li>
<li>原型模式</li>
<li>中介模式</li>
<li>代理模式</li>
<li>观察者模式</li>
<li>命令模式</li>
</ol>
<h2 id="设计模式的具体实现和理解">设计模式的具体实现和理解</h2><h3 id="简单工厂">简单工厂</h3><p><strong>使用情景</strong>：<br>不想让调用者，知道具体实现，直接返回一个接口，让操作者去调用。对外仅仅暴漏接口和<br>简单工厂，具体的实现隐藏起来。<br><strong>结构说明</strong>：<br>接口和具体实现类，以及工厂，处于一层，调用者处于另外一层。<br>如果需要调用不同的实现，可以选择  </p>
<ol>
<li>带入参</li>
<li>或者自己读取配置文件。<br>带入参，就意味着，调用者需要知道内部具体实现的<br>部分细节了，这加大了，调用者的学习成本，值得注意的一点。<br><strong>优缺点</strong>：<br>改模式的优点是：调用者不关心具体的实现。把调用者和具体实现类解耦。<br>缺点：如果需要带入参，那么调用者就需要知道部分具体实现细节。</li>
</ol>
<h3 id="外观模式">外观模式</h3><p><strong>使用情景</strong>：调用者需要分别调用不同子模块的方法，来实现一个需求。外观模式，就是用了一个<br>对各子模块的包装( Facade )了，调用者只需要调用 Facade 就可以实现分别调用各子模块了。<br><strong>结构说明</strong>：<br>  Facade 包装一下各子模块的功能，对外提供一个包装后的功能方法，对外提供。<br><strong>优缺点</strong>：<br>优点是：调用者不关心那么多子模块的实现了，直接调用包装后的 Facade 。<br>缺点： 如果一些简单的功能，不知道是直接调用具体的模块好，还是用 Facade 好。<br><strong>和相关模式的区别</strong>：  </p>
<ol>
<li>简单工厂模式<br><strong>相同点是</strong> 都是不让调用者知道具体的实现细节，节省调用者的理解成本。<br><strong>不同点是</strong> 简单工厂返回的是接口，外观，是通过一个包装类来提供的。  </li>
</ol>
<h3 id="适配器模式">适配器模式</h3><p>简单来举例说，比如，第一版本一个类 A，有方法 A1 和 A2 ，现在第二版本，类 A 的升级类 B ，<br>有方法 B1 , B2 , B3 , B4 。但是呢，现在是处于第一版本向第二版本的过渡期，既要保持第二版本<br>的实现（虽然不大稳定），也要拥有之前版本的实现。一般来说，如果从业务角度，如果 A1  方法和 B1<br>方法，较接近，而且参数之类也可以兼容的话，就可以在类 B 的方法 B1 中，调用类 A  的方法 A1 。<br>至于类 A  什么时候传入到类 B 中，可以随意选择了，但是必须得在调用方法 B1 之前。</p>
<h2 id="工厂方法模式">工厂方法模式</h2><p>和简单工厂比较像。他把公共逻辑写完，剩下的未知的（或者个性化）实现，写一个抽象方法，<br>留给子类去定制化实现。</p>
<h2 id="抽象工厂方法">抽象工厂方法</h2><p>和工厂方法类似，并且会常常一起使用，主要特点，就是为一个特定的产品，实现定制化一个 Factory 。</p>
<h2 id="原型模式">原型模式</h2><p>java 中的 clone 是浅度克隆，基本类型没问题，但是引用类型的话，clone 是直接把对象的值，<br>拷贝过去的。因此需要自己重新复制。</p>
<h2 id="中介模式">中介模式</h2><p>和外观模式有点像，对象之间通信比较复杂，并且频繁的话，可以抽离出来，让 Mediator 来做<br>这些复杂的操作，中介模式的结构并不固定。</p>
<h2 id="代理模式">代理模式</h2><p>在调用者和被访问的对象之间，引入一定程度上的中间者，试图不让调用者和被访问的对象直接联系。<br>这么做的原因可能各种各样。例如，目标对象，可能有很多公开方法，但是这些公开方法，大部分只是<br>希望给自己内部使用，仅有小部分是对开公开的。因此可以封装一层。</p>
<h2 id="观察者模式">观察者模式</h2><p>一对多的关系，被观察者的改变，会引起众多观察者的关注。需要注意观察者的生命周期，需要及时注销。</p>
<h2 id="命令模式">命令模式</h2><p>就是调用者，不关心具体的实现，</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/17/再读-volley/" itemprop="url">
                  再读 volley
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-04-17T12:21:44+08:00" content="2016-04-17">
              2016-04-17
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <p>之前读过 Volley 的源码，可是仅仅是从使用方面在看，一些实现的细节，有不少疑点。volley 在<br>设计模式上，也是很好的学习素材，每次读，都有不少收获。<br>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/04/17/再读-volley/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/15/inflate-流程/" itemprop="url">
                  inflate 流程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-04-15T10:24:52+08:00" content="2016-04-15">
              2016-04-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp; 分类于
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <h1 id="前言">前言</h1><p>我们要加载 xml 上的 View 时，大抵都会用上下面几种方法。</p>
<ol>
<li>inflater.inflate(R.layout.frag_home_detail_scroll, null)</li>
<li>inflater.inflate(R.layout.frag_home_detail_scroll, null, false)</li>
<li>LayoutInflater.from(mContext).inflater()
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/04/15/inflate-流程/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



        </div>

        


        

      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="aheadlcx" itemprop="image"/>
          <p class="site-author-name" itemprop="name">aheadlcx</p>
        </div>
        <p class="site-description motion-element" itemprop="description"></p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">29</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">3</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">15</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aheadlcx</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
    
    

  


  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
<script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

<script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script>


  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  

  <script type="text/javascript" src="/js/bootstrap.js"></script>

  
  

  
  

</body>
</html>
