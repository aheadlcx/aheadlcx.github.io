<!doctype html>
<html class="theme-next   use-motion ">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
    <link href='//fonts.lug.ustc.edu.cn/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />













<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Believe yourself">
<meta property="og:url" content="http://www.aheadlcx.xyz/page/2/index.html">
<meta property="og:site_name" content="Believe yourself">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Believe yourself">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'post',
    motion: true
  };
</script>

  <title> Believe yourself </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Believe yourself</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <section id="posts" class="posts-expand">

    

    
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/23/AndroidTV-开发之焦点处理/" itemprop="url">
                  AndroidTV 开发之焦点处理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-09-23T14:30:16+08:00" content="2016-09-23">
              2016-09-23
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <p>TV 知识点学习整理笔记。<br>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/09/23/AndroidTV-开发之焦点处理/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/08/Activity-启动流程/" itemprop="url">
                  Activity 启动流程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-08-08T18:09:49+08:00" content="2016-08-08">
              2016-08-08
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="基本概念">基本概念</h2><p>客户端和服务端，Android 设计上是这样区分的，这2个是在不同的进程里面，下面分别用<br>进程 C（client） 代指客户端，进程 S （server），代指 服务端。</p>
<h2 id="Activity_启动流程">Activity 启动流程</h2><h3 id="Activity_代码部分">Activity 代码部分</h3><p>都是通过 Activity 的 startActivityForResult 方法来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(Intent intent, <span class="keyword">int</span> requestCode, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Instrumentation.ActivityResult ar =</span><br><span class="line">                mInstrumentation.execStartActivity(</span><br><span class="line">                    <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">                    intent, requestCode, options);</span><br><span class="line">            <span class="keyword">if</span> (ar != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mMainThread.sendActivityResult(</span><br><span class="line">                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                    ar.getResultData());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//.... ignore some code</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以发现是通过 mInstrumentation 的 execStartActivity 方法来实现的。跟下去看看。而<br>mMainThread 是 ActivityThread ，这个本质不是线程，没有继承 Thread ，但是他代表了这个<br>进程的主线程，他里面有一个叫 H 的 Handler ，负责处理各种消息。</p>
<h3 id="mInstrumentation_部分">mInstrumentation 部分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span><br><span class="line">            Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">            Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">        IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">        <span class="keyword">if</span> (mActivityMonitors != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mSync) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> N = mActivityMonitors.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                    <span class="keyword">final</span> ActivityMonitor am = mActivityMonitors.get(i);</span><br><span class="line">                    <span class="keyword">if</span> (am.match(who, <span class="keyword">null</span>, intent)) &#123;</span><br><span class="line">                        am.mHits++;</span><br><span class="line">                        <span class="keyword">if</span> (am.isBlocking()) &#123;</span><br><span class="line">                            <span class="keyword">return</span> requestCode &gt;= <span class="number">0</span> ? am.getResult() : <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            intent.migrateExtraStreamToClipData();</span><br><span class="line">            intent.prepareToLeaveProcess();</span><br><span class="line">            <span class="keyword">int</span> result = ActivityManagerNative.getDefault()</span><br><span class="line">                .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                        intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                        token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                        requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">            checkStartActivityResult(result, intent);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ActivityManagerNative.getDefault() 获得的是 ActivityManagerProxy 。这个东西的作用<br>是 进程 C 单向的和 进程 S 通讯，即进程 C 发消息给进程 S。</p>
<h3 id="ActivityManagerProxy_部分">ActivityManagerProxy 部分</h3><p>有2个问题需要关注  </p>
<ul>
<li>ActivityManagerProxy 是如何创建的。</li>
<li>ActivityManagerProxy 是如何和 AMS 通信的。</li>
</ul>
<h4 id="创建">创建</h4><p>这里是用了一个单例模式（ Singleton ），来确保这个 ActivityManagerProxy 是单例。然后<br>再用这个 IBinder 来作为参数构造 ActivityManagerProxy ，并且把这个 IBinder 保存在<br>ActivityManagerProxy 内部的成员变量中。<strong>mark,unkown</strong> ServiceManager 的工作<br>原理，暂时不明白，先不追究细节。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IBinder b = ServiceManager.getService(<span class="string">"activity"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">            Log.v(<span class="string">"ActivityManager"</span>, <span class="string">"default service binder = "</span> + b);</span><br><span class="line">        &#125;</span><br><span class="line">        IActivityManager am = asInterface(b);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">            Log.v(<span class="string">"ActivityManager"</span>, <span class="string">"default service = "</span> + am);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> am;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">asInterface</span><span class="params">(IBinder obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        IActivityManager in =</span><br><span class="line">            (IActivityManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">        <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> in;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ActivityManagerProxy(obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="ActivityManagerProxy_和_AMS_的单向通信">ActivityManagerProxy 和 AMS 的单向通信</h4><p>ActivityManagerNative.getDefault().startActivity() 方法，最终调用的是，<br>ActivityManagerProxy 的方法。<br>先来看看几个类的继承关系  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerProxy</span> <span class="keyword">implements</span> <span class="title">IActivityManager</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerService</span> <span class="keyword">extends</span> <span class="title">ActivityManagerNative</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityManagerNative</span> <span class="keyword">extends</span> <span class="title">Binder</span>   </span><br><span class="line"><span class="keyword">implements</span> <span class="title">IActivityManager</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>再来看看这个方法的源码  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage, Intent intent,</span><br><span class="line">            String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span><br><span class="line">            <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        Parcel data = Parcel.obtain();</span><br><span class="line">        Parcel reply = Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">        data.writeStrongBinder(caller != <span class="keyword">null</span> ? caller.asBinder() : <span class="keyword">null</span>);</span><br><span class="line">        data.writeString(callingPackage);</span><br><span class="line">        intent.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">        data.writeString(resolvedType);</span><br><span class="line">        data.writeStrongBinder(resultTo);</span><br><span class="line">        data.writeString(resultWho);</span><br><span class="line">        data.writeInt(requestCode);</span><br><span class="line">        data.writeInt(startFlags);</span><br><span class="line">        <span class="keyword">if</span> (profilerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            data.writeInt(<span class="number">1</span>);</span><br><span class="line">            profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data.writeInt(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">            data.writeInt(<span class="number">1</span>);</span><br><span class="line">            options.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data.writeInt(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">        reply.readException();</span><br><span class="line">        <span class="keyword">int</span> result = reply.readInt();</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ActivityManagerProxy 对于接口 IActivityManager 的方法实现，都是交给 Binder 来实现，<br>对于具体是调用的那个方法，可以看到 mRemote.transact(START_ACTIVITY_TRANSACTION);<br>有这么一个标识。可以让服务端识别，到底调用那个方法。<br><strong>mark unkown</strong> Binder 的具体实现，暂时不是很理解。</p>
<h2 id="疑问点">疑问点</h2><h3 id="Instrumentation">Instrumentation</h3><p>整个进程只会存在一个 Instrumentation 对象。他是什么实际构造的，以及怎么保证进程唯一的。</p>
<h3 id="Acitivity_合法性">Acitivity 合法性</h3><p>怎样检查合法性的</p>
<h3 id="Application_的创建以及，创建之后怎么创建第一个_Activity">Application 的创建以及，创建之后怎么创建第一个 Activity</h3><h3 id="ApplicationThread">ApplicationThread</h3><p>这货本质是一个 Binder ，是什么时候创建出来的，由谁创建的，干什么用。</p>
<h2 id="学习笔录">学习笔录</h2><h3 id="Activity_整个启动流程">Activity 整个启动流程</h3><ul>
<li>Activity 的 startActivity 方法</li>
<li>AMS 里面，包含 ActivityStackSupervisor 以及 ActivityStack 的一系列操作</li>
<li>通过 Binder 驱动，回到 ApplicationThread 的 scheduleLaunchActivity 方法</li>
<li>来到一个 ActivityThread 的成员对象 mH （类型为 H 的 handler）</li>
<li>AcitivityThread 的 handleLaunchActivity 方法</li>
<li>AcitivityThread 的 performLaunchActivity 方法<ul>
<li>通过 Instrumentation 创建 Activity 的实例</li>
<li>看是否需要创建 Application<ul>
<li>如果需要创建，就先调用 Application 的 attach 方法</li>
<li>再调用 Application 的 onCreate 方法</li>
</ul>
</li>
<li>调用 Activity 的 attach 方法</li>
<li>调用 Activity 的 onCreate 方法</li>
</ul>
</li>
</ul>
<h4 id="AcitivityThread_的_performLaunchActivity_方法">AcitivityThread 的 performLaunchActivity 方法</h4><h5 id="创建_Activity">创建 Activity</h5><p>通过 Instrumentation 来创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Activity activity = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">            activity = mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">            StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">            r.intent.setExtrasClassLoader(cl);</span><br><span class="line">            r.intent.prepareToEnterProcess();</span><br><span class="line">            <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">                r.state.setClassLoader(cl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Unable to instantiate activity "</span> + component</span><br><span class="line">                    + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h5 id="通过_LoadedApk_看是否需要创建_Application">通过 LoadedApk 看是否需要创建 Application</h5><p>ActivityClientRecord 里面的 packageInfo 类型是 LoadedApk ，他包含了一个<br>Application ，如果已经存在了，就直接返回，如果没有则创建一个(还是通过 mInstrumentation )。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">makeApplication</span><span class="params">(<span class="keyword">boolean</span> forceDefaultAppClass,</span><br><span class="line">            Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mApplication != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mApplication;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Application app = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        String appClass = mApplicationInfo.className;</span><br><span class="line">        <span class="keyword">if</span> (forceDefaultAppClass || (appClass == <span class="keyword">null</span>)) &#123;</span><br><span class="line">            appClass = <span class="string">"android.app.Application"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">            <span class="keyword">if</span> (!mPackageName.equals(<span class="string">"android"</span>)) &#123;</span><br><span class="line">                initializeJavaContextClassLoader();</span><br><span class="line">            &#125;</span><br><span class="line">            ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, <span class="keyword">this</span>);</span><br><span class="line">            app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                    cl, appClass, appContext);</span><br><span class="line">            appContext.setOuterContext(app);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mActivityThread.mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Unable to instantiate application "</span> + appClass</span><br><span class="line">                    + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mActivityThread.mAllApplications.add(app);</span><br><span class="line">        mApplication = app;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (instrumentation != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                instrumentation.callApplicationOnCreate(app);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!instrumentation.onException(app, e)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to create application "</span> + app.getClass().getName()</span><br><span class="line">                        + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Rewrite the R 'constants' for all library apks.</span></span><br><span class="line">        SparseArray&lt;String&gt; packageIdentifiers = getAssets(mActivityThread)</span><br><span class="line">                .getAssignedPackageIdentifiers();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = packageIdentifiers.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> id = packageIdentifiers.keyAt(i);</span><br><span class="line">            <span class="keyword">if</span> (id == <span class="number">0x01</span> || id == <span class="number">0x7f</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rewriteRValues(getClassLoader(), packageIdentifiers.valueAt(i), id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> app;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="在_Instrumentation_中_Application_的创建过程">在 Instrumentation 中 Application 的创建过程</h6><p>结合 LoadedApk 的 makeApplication 方法，可以看出，application是先调用的 attach方法，<br>再通过 instrumentation.callApplicationOnCreate(app);  ，来调用 application 的<br>onCreate 方法.  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> Application <span class="title">newApplication</span><span class="params">(Class&lt;?&gt; clazz, Context context)</span></span><br><span class="line">            <span class="keyword">throws</span> InstantiationException, IllegalAccessException,</span><br><span class="line">            ClassNotFoundException </span>&#123;</span><br><span class="line">        Application app = (Application)clazz.newInstance();</span><br><span class="line">        app.attach(context);</span><br><span class="line">        <span class="keyword">return</span> app;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="创建_Context_并且先后调用_activity_的_attach_和_onCreate_方法">创建 Context 并且先后调用 activity 的 attach 和 onCreate 方法</h5><p>Acitivity 的 attach 方法会创建 Window （实际是 PhoneWindow ）。在 activity 的<br>onCreate 方法中，setContentView ，仅仅是会让 window 初始化好 DecorView ，这个时候<br>并没有把这个 DecorView 添加到 WindowManagerGlobal</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line">                CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">                Configuration config = <span class="keyword">new</span> Configuration(mCompatConfiguration);</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_CONFIGURATION) Slog.v(TAG, <span class="string">"Launching activity "</span></span><br><span class="line">                        + r.activityInfo.name + <span class="string">" with config "</span> + config);</span><br><span class="line">                activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                        r.referrer, r.voiceInteractor);</span><br></pre></td></tr></table></figure>
<h5 id="在_ActivityThread_的_HandleResumeActivity_方法">在 ActivityThread 的 HandleResumeActivity 方法</h5><p>先手调用 activity 的 onResume 和 makeVisible 方法，在 makeVisible 方法中，会让<br>Windowmanager 的 addView 方法。这其实最后调用的是 WindowManagerGlobal 的<br>addView 方法。在这里，创建 ViewRootImp 并且调用它的 setView 方法，这里会通过<br>WindowmanagerService 来做处理。这里涉及到 Binder 驱动。还是没明白，怎样才算真正<br>添加到屏幕了，这个 View 。</p>
<h3 id="Activity_的_View_显示流程">Activity 的 View 显示流程</h3><p>一个 View 的显示，需要 WindowManager.addView 之后才可以显示的。<br>View 显示的流程如下：  </p>
<ul>
<li><ol>
<li>Window 的创建，在 Activity 的 attach 方法中</li>
</ol>
</li>
<li><ol>
<li>DecorView 的创建，我们一般会在 Activity 的 onCreate 方法中会调用 setContentView<br>方法，在这个方法中，会调用 PhoneWindow 的 setContentView 方法。</li>
</ol>
</li>
<li><ol>
<li>View 的最终显示，是在 Activity 的 makeVisible 方法中，该方法会调用 WindowManager<br>的 addView 方法，该 WindowManager 实现者是 WindowManagerImpl ，在其 addView 方法里面<br>调用的是 WindowManagerGlobal 的 addView 方法</li>
</ol>
<ul>
<li><ol>
<li>创建 ViewRootImpl</li>
</ol>
</li>
<li><ol>
<li>调用 ViewRootImpl 的 setView 方法</li>
</ol>
</li>
<li><ol>
<li>在 ViewRootImpl 的 setView 方法里面，会调用一个 IWindowSession ( 实际实现是<br>Session ) 的 addToDisplay 方法，完成 Window 的添加</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="遗留疑问">遗留疑问</h1><ul>
<li>Activity 的 View 什么时候被销毁。销毁逻辑代码在何处。 added 2016.12.10</li>
</ul>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/28/postEffective-Java-笔记/" itemprop="url">
                  Effective Java 笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-07-28T17:18:34+08:00" content="2016-07-28">
              2016-07-28
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <p>记录一下 Effective Java 的读书笔记，以及当时的思考。<br>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/07/28/postEffective-Java-笔记/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/20/post-Behavior-细节笔记/" itemprop="url">
                  Behavior 细节笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-06-20T15:27:27+08:00" content="2016-06-20">
              2016-06-20
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <h2 id="AppBarLayout_细节笔记">AppBarLayout 细节笔记</h2><ol>
<li>滚动的实现<br>和 CoordinatorLayout 配合时，如果触摸到 AppBarLayout 部分， AppBarLayout 的滚动<br>是在 Behavior (HeaderBehavior) 的 onTouchEvent 方法中处理的。<br>在 ACTION_MOVE 中可以看到，是通过 scroll 方法实现滚动的。实际实现就是改变 view 的 top 值。<br>在 ACTION_UP 中，调用 fling 来实现滑动至完整的 view 。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(CoordinatorLayout parent, V child, MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mTouchSlop &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mTouchSlop = ViewConfiguration.get(parent.getContext()).getScaledTouchSlop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (MotionEventCompat.getActionMasked(ev)) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> x = (<span class="keyword">int</span>) ev.getX();</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> y = (<span class="keyword">int</span>) ev.getY();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (parent.isPointInChildBounds(child, x, y) &amp;&amp; canDragView(child)) &#123;</span><br><span class="line">                    mLastMotionY = y;</span><br><span class="line">                    mActivePointerId = MotionEventCompat.getPointerId(ev, <span class="number">0</span>);</span><br><span class="line">                    ensureVelocityTracker();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> activePointerIndex = MotionEventCompat.findPointerIndex(ev,</span><br><span class="line">                        mActivePointerId);</span><br><span class="line">                <span class="keyword">if</span> (activePointerIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> y = (<span class="keyword">int</span>) MotionEventCompat.getY(ev, activePointerIndex);</span><br><span class="line">                <span class="keyword">int</span> dy = mLastMotionY - y;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!mIsBeingDragged &amp;&amp; Math.abs(dy) &gt; mTouchSlop) &#123;</span><br><span class="line">                    mIsBeingDragged = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (dy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        dy -= mTouchSlop;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dy += mTouchSlop;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mIsBeingDragged) &#123;</span><br><span class="line">                    mLastMotionY = y;</span><br><span class="line">                    <span class="comment">// We're being dragged so scroll the ABL</span></span><br><span class="line">                    scroll(parent, child, dy, getMaxDragOffset(child), <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                <span class="keyword">if</span> (mVelocityTracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mVelocityTracker.addMovement(ev);</span><br><span class="line">                    mVelocityTracker.computeCurrentVelocity(<span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">float</span> yvel = VelocityTrackerCompat.getYVelocity(mVelocityTracker,</span><br><span class="line">                            mActivePointerId);</span><br><span class="line">                    fling(parent, child, -getScrollRangeForDragFling(child), <span class="number">0</span>, yvel);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// $FALLTHROUGH</span></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_CANCEL: &#123;</span><br><span class="line">                mIsBeingDragged = <span class="keyword">false</span>;</span><br><span class="line">                mActivePointerId = INVALID_POINTER;</span><br><span class="line">                <span class="keyword">if</span> (mVelocityTracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mVelocityTracker.recycle();</span><br><span class="line">                    mVelocityTracker = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mVelocityTracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mVelocityTracker.addMovement(ev);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>layout_anchorGravity 和 layout_gravity 的区别<br>layout_anchorGravity 是相对于依赖的 View 的，layout_gravity 在</li>
</ol>
<p><strong>undo</strong> 依赖于一个 View ，是否可以解决，一个 View 的位置需要根据另外一个 View<br>的位置而定的需求。应该可以的，改天实现以下。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/13/NestedScrolling-流程理解/" itemprop="url">
                  NestedScrolling 流程理解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2016-06-13T15:57:52+08:00" content="2016-06-13">
              2016-06-13
            </time>
          </span>

          

          
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <p>参考文章</p>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000002873657" target="_blank" rel="external">Android 嵌套滑动机制（NestedScrolling）</a></p>
</blockquote>
<h1 id="前言">前言</h1><p>传统的 Android 的 Touch 事件分发机制，主要涉及到下面3个方法  </p>
<ol>
<li>dispatchTouchEvent</li>
<li>onInterceptTouchEvent</li>
<li>onTouchEvent</li>
</ol>
<p>其中后面2个方法，是在第一个方法 dispatchTouchEvent 中调用的。在这个涉及里面下，如果父 View<br>把 touch 事件传递给子 View ，并且子 View 消费了这个事件，那么父 View 就再也不能获得这个<br>touch 事件了。（其实这不是绝对的，只是传统的 Android Touch 事件传递设计初衷就这样，<br>子 View 的 Touch 事件也是经过父 View 的 dispatchTouchEvent 方法的嘛），这种设计，只是<br>不能让父 View 和子 View ，经过交流，来回的传递 Touch 事件。  </p>
<p>在 design 中出现了新的设计实现，还可以兼容旧版本，就是 NestedScrolling 了，<br>就是嵌套滚动的意思 。这套设计的实现，主要涉及到下面几个接口（类）  </p>
<ol>
<li>NestedScrollingChild</li>
<li>NestedScrollingChildHelper</li>
<li>NestedScrollingParent</li>
<li>NestedScrollingParentHelper</li>
</ol>
<h1 id="类简介">类简介</h1><h2 id="NestedScrollingChild">NestedScrollingChild</h2><p><img src="https://raw.githubusercontent.com/aheadlcx/myPhotos/master/NestedScroll/NestedScrollingChild.png" alt=""><br>如果想要配合 ViewGroup 实现嵌套滚动， View 或者 View 的子类就得实现接口<br>NestedScrollingChild .并且需要创建一个 final 的 NestedScrollingChildHelper 作为<br>成员变量，并且将相同点方法签名，都交给 NestedScrollingChildHelper 来代理。</p>
<h2 id="NestedScrollingChildHelper">NestedScrollingChildHelper</h2><p><img src="https://raw.githubusercontent.com/aheadlcx/myPhotos/master/NestedScroll/NestedScrollingChildHelper.png" alt=""><br>这是一个帮助工具类，来实现嵌套滚动的，兼容5.0以前的版本。<br>View 的子类应该创建一个 NestedScrollingChildHelper final 实例，并且把 View 和<br>NestedScrollingChildHelper ，方法签名相同的方法，都委托给  NestedScrollingChildHelper<br>来处理。</p>
<h2 id="NestedScrollingParent">NestedScrollingParent</h2><p><img src="https://raw.githubusercontent.com/aheadlcx/myPhotos/master/NestedScroll/NestedScrollingParent.png" alt=""><br>ViewGroup 的子类应该实现的接口，并且需要创建一个 final 的成员变量<br>NestedScrollingParentHelper ，和 NestedScrollingChild 类似。</p>
<h2 id="NestedScrollingParentHelper">NestedScrollingParentHelper</h2><p><img src="https://raw.githubusercontent.com/aheadlcx/myPhotos/master/NestedScroll/NestedScrollingParentHelper.png" alt=""><br>作用和 NestedScrollingChildHelper 类似。</p>
<h1 id="嵌套滚动原理">嵌套滚动原理</h1><p>我们知道新版本的 RecycleView 是支持嵌套滚动的，所以我们直接抓源码看就好了。<br>我们用 RecycleView 作为 NestedScrollingChild ， CoordinatorLayout 作为<br>NestedScrollingParent 来做例子分析。在这个例子中，整个嵌套 touch 事件分发的流程图如下  </p>
<p><img src="https://raw.githubusercontent.com/aheadlcx/myPhotos/master/NestedScroll/NestedScroll_Processon.png" alt=""></p>
<p>整个流程涉及到的类比较多，而且逻辑也比较复杂。总体而言，需要一个 CoordinatorLayout 直接<br>包裹住所有直接子 View （这也不是绝对的，不过这就是人家的设计，如果需要，当然可以重新自定义<br>一个类似于 CoordinatorLayout 的 ViewGroup 了）。如果直接子 View 的 Behavior  没有拦截<br>touch 事件的话，那么嵌套事件就是从子 View 开始发起的。这里先分开3部分来看，分别从 DOWN ，<br>MOVE 和 UP 事件来看。</p>
<h2 id="嵌套中的_DWON_事件">嵌套中的 DWON 事件</h2><h3 id="起始于_RecycleView_中的_onTouchEvent">起始于 RecycleView 中的 onTouchEvent</h3><p>直接上代码 (精简版)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> canScrollHorizontally = mLayout.canScrollHorizontally();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> canScrollVertically = mLayout.canScrollVertically();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> eventAddedToVelocityTracker = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> MotionEvent vtev = MotionEvent.obtain(e);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = MotionEventCompat.getActionMasked(e);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = MotionEventCompat.getActionIndex(e);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> nestedScrollAxis = ViewCompat.SCROLL_AXIS_NONE;</span><br><span class="line">                <span class="keyword">if</span> (canScrollHorizontally) &#123;</span><br><span class="line">                    nestedScrollAxis |= ViewCompat.SCROLL_AXIS_HORIZONTAL;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (canScrollVertically) &#123;</span><br><span class="line">                    nestedScrollAxis |= ViewCompat.SCROLL_AXIS_VERTICAL;</span><br><span class="line">                &#125;</span><br><span class="line">                startNestedScroll(nestedScrollAxis);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> x = (<span class="keyword">int</span>) (MotionEventCompat.getX(e, index) + <span class="number">0.5f</span>);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> y = (<span class="keyword">int</span>) (MotionEventCompat.getY(e, index) + <span class="number">0.5f</span>);</span><br><span class="line">                <span class="keyword">int</span> dx = mLastTouchX - x;</span><br><span class="line">                <span class="keyword">int</span> dy = mLastTouchY - y;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dispatchNestedPreScroll(dx, dy, mScrollConsumed, mScrollOffset)) &#123;</span><br><span class="line">                    dx -= mScrollConsumed[<span class="number">0</span>];</span><br><span class="line">                    dy -= mScrollConsumed[<span class="number">1</span>];</span><br><span class="line">                    vtev.offsetLocation(mScrollOffset[<span class="number">0</span>], mScrollOffset[<span class="number">1</span>]);</span><br><span class="line">                    <span class="comment">// Updated the nested offsets</span></span><br><span class="line">                    mNestedOffsets[<span class="number">0</span>] += mScrollOffset[<span class="number">0</span>];</span><br><span class="line">                    mNestedOffsets[<span class="number">1</span>] += mScrollOffset[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mScrollState != SCROLL_STATE_DRAGGING) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> startScroll = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (canScrollHorizontally &amp;&amp; Math.abs(dx) &gt; mTouchSlop) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (dx &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            dx -= mTouchSlop;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            dx += mTouchSlop;</span><br><span class="line">                        &#125;</span><br><span class="line">                        startScroll = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (canScrollVertically &amp;&amp; Math.abs(dy) &gt; mTouchSlop) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (dy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            dy -= mTouchSlop;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            dy += mTouchSlop;</span><br><span class="line">                        &#125;</span><br><span class="line">                        startScroll = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (startScroll) &#123;</span><br><span class="line">                        setScrollState(SCROLL_STATE_DRAGGING);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mScrollState == SCROLL_STATE_DRAGGING) &#123;</span><br><span class="line">                    mLastTouchX = x - mScrollOffset[<span class="number">0</span>];</span><br><span class="line">                    mLastTouchY = y - mScrollOffset[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (scrollByInternal(</span><br><span class="line">                            canScrollHorizontally ? dx : <span class="number">0</span>,</span><br><span class="line">                            canScrollVertically ? dy : <span class="number">0</span>,</span><br><span class="line">                            vtev)) &#123;</span><br><span class="line">                        getParent().requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">                resetTouch();</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!eventAddedToVelocityTracker) &#123;</span><br><span class="line">            mVelocityTracker.addMovement(vtev);</span><br><span class="line">        &#125;</span><br><span class="line">        vtev.recycle();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，是直接调用的方法 startNestedScroll ，那么跟下去看看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNestedScroll</span><span class="params">(<span class="keyword">int</span> axes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getScrollingChildHelper().startNestedScroll(axes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再跟看看 getScrollingChildHelper 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> NestedScrollingChildHelper <span class="title">getScrollingChildHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mScrollingChildHelper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mScrollingChildHelper = <span class="keyword">new</span> NestedScrollingChildHelper(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mScrollingChildHelper;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>一个简单的单例模式，把自己(RecycleView) 传递进去了。那么我们跟下去看看<br>mScrollingChildHelper.startNestedScroll 方法。</p>
<h3 id="mScrollingChildHelper-startNestedScroll_方法">mScrollingChildHelper.startNestedScroll 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Start a new nested scroll for this view.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This is a delegate method. Call it from your &#123;<span class="doctag">@link</span> android.view.View View&#125; subclass</span><br><span class="line"> * method/&#123;<span class="doctag">@link</span> NestedScrollingChild&#125; interface method with the same signature to implement</span><br><span class="line"> * the standard policy.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> axes Supported nested scroll axes.</span><br><span class="line"> *             See &#123;<span class="doctag">@link</span> NestedScrollingChild#startNestedScroll(int)&#125;.</span><br><span class="line"> * <span class="doctag">@return</span> true if a cooperating parent view was found and nested scrolling started successfully</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNestedScroll</span><span class="params">(<span class="keyword">int</span> axes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasNestedScrollingParent()) &#123;</span><br><span class="line">        <span class="comment">// Already in progress</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isNestedScrollingEnabled()) &#123;</span><br><span class="line">        ViewParent p = mView.getParent();</span><br><span class="line">        View child = mView;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ViewParentCompat.onStartNestedScroll(p, child, mView, axes)) &#123;</span><br><span class="line">                mNestedScrollingParent = p;</span><br><span class="line">                ViewParentCompat.onNestedScrollAccepted(p, child, mView, axes);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> View) &#123;</span><br><span class="line">                child = (View) p;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先做了检查，hasNestedScrollingParent 方法就检查了 mNestedScrollingParent 是否为空，<br>如果不为空，就代表已经在嵌套滚动当中了，就不进行其他处理了，直接返回 true。 从后面的代码可以<br>看到 mNestedScrollingParent 的赋值就是 mView 的父类（或者父父类）。<br>接下来我们看 ViewParentCompat.onStartNestedScroll 方法</p>
<h3 id="ViewParentCompat-onStartNestedScroll_方法">ViewParentCompat.onStartNestedScroll 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(ViewParent parent, View child, View target,</span><br><span class="line">        <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IMPL.onStartNestedScroll(parent, child, target, nestedScrollAxes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ViewParentCompatImpl IMPL;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> version = Build.VERSION.SDK_INT;</span><br><span class="line">    <span class="keyword">if</span> (version &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">        IMPL = <span class="keyword">new</span> ViewParentCompatLollipopImpl();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (version &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">        IMPL = <span class="keyword">new</span> ViewParentCompatKitKatImpl();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (version &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">        IMPL = <span class="keyword">new</span> ViewParentCompatICSImpl();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        IMPL = <span class="keyword">new</span> ViewParentCompatStubImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewParentCompatLollipopImpl</span> <span class="keyword">extends</span> <span class="title">ViewParentCompatKitKatImpl</span> </span>&#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(ViewParent parent, View child, View target,</span><br><span class="line">                <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ViewParentCompatLollipop.onStartNestedScroll(parent, child, target,</span><br><span class="line">                    nestedScrollAxes);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewParentCompatStubImpl</span> <span class="keyword">implements</span> <span class="title">ViewParentCompatImpl</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">requestSendAccessibilityEvent</span><span class="params">(</span><br><span class="line">            ViewParent parent, View child, AccessibilityEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Emulate what ViewRootImpl does in ICS and above.</span></span><br><span class="line">        <span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> AccessibilityManager manager = (AccessibilityManager) child.getContext()</span><br><span class="line">                .getSystemService(Context.ACCESSIBILITY_SERVICE);</span><br><span class="line">        manager.sendAccessibilityEvent(event);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(ViewParent parent, View child, View target,</span><br><span class="line">            <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (parent <span class="keyword">instanceof</span> NestedScrollingParent) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((NestedScrollingParent) parent).onStartNestedScroll(child, target,</span><br><span class="line">                    nestedScrollAxes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看到，ViewParentCompat 是交给一个成员变量 IMPL 来处理的，这个 IMPL 在<br>不同系统版本又有不同的实现，5.0 以上是 ViewParentCompatLollipopImpl ，5.0 以下 是<br>ViewParentCompatStubImpl ， ViewParentCompat 是一个兼容库，5.0 以上<br>就直接调用 View 或者 ViewGroup 的方法，5.0 以下就看是否实现了<br>NestedScrollingChild 和 NestedScrollingParent ，如果实现了就调用相关的方法，否则啥也<br>不干了。因此 ListView 本身是不支持嵌套滚动的，除非继承 NestedScrollingChild 并且实现<br>相关的方法。  </p>
<h3 id="CoordinatorLayout_的_onStartNestedScroll_方法">CoordinatorLayout 的 onStartNestedScroll 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(View child, View target, <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View view = getChildAt(i);</span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) view.getLayoutParams();</span><br><span class="line">            <span class="keyword">final</span> Behavior viewBehavior = lp.getBehavior();</span><br><span class="line">            <span class="keyword">if</span> (viewBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> accepted = viewBehavior.onStartNestedScroll(<span class="keyword">this</span>, view, child, target,</span><br><span class="line">                        nestedScrollAxes);</span><br><span class="line">                handled |= accepted;</span><br><span class="line"></span><br><span class="line">                lp.acceptNestedScroll(accepted);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lp.acceptNestedScroll(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，就是遍历所有子 View 的 Behavior 的 onStartNestedScroll 方法，并且记录<br>返回值到子 View 的 LayoutParams 中。返回 true ，代表这个 Behavior 想接受这个嵌套滚动。<br>只要有一个 Behavior 返回了 true ，那么这个方法中的返回值 就为 true 。接下来再看看<br>Behavior 的 onStartNestedScroll 方法。</p>
<h3 id="Behavior_的_onStartNestedScroll_方法。">Behavior 的 onStartNestedScroll 方法。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Called when a descendant of the CoordinatorLayout attempts to initiate a nested scroll.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Any Behavior associated with any direct child of the CoordinatorLayout may respond</span><br><span class="line"> * to this event and return true to indicate that the CoordinatorLayout should act as</span><br><span class="line"> * a nested scrolling parent for this scroll. Only Behaviors that return true from</span><br><span class="line"> * this method will receive subsequent nested scroll events.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> coordinatorLayout the CoordinatorLayout parent of the view this Behavior is</span><br><span class="line"> *                          associated with</span><br><span class="line"> * <span class="doctag">@param</span> child the child view of the CoordinatorLayout this Behavior is associated with</span><br><span class="line"> * <span class="doctag">@param</span> directTargetChild the child view of the CoordinatorLayout that either is or</span><br><span class="line"> *                          contains the target of the nested scroll operation</span><br><span class="line"> * <span class="doctag">@param</span> target the descendant view of the CoordinatorLayout initiating the nested scroll</span><br><span class="line"> * <span class="doctag">@param</span> nestedScrollAxes the axes that this nested scroll applies to. See</span><br><span class="line"> *                         &#123;<span class="doctag">@link</span> ViewCompat#SCROLL_AXIS_HORIZONTAL&#125;,</span><br><span class="line"> *                         &#123;<span class="doctag">@link</span> ViewCompat#SCROLL_AXIS_VERTICAL&#125;</span><br><span class="line"> * <span class="doctag">@return</span> true if the Behavior wishes to accept this nested scroll</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@see</span> NestedScrollingParent#onStartNestedScroll(View, View, int)</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(CoordinatorLayout coordinatorLayout,</span><br><span class="line">        V child, View directTargetChild, View target, <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法，默认是返回 false ，几个形参容易搞错。</p>
<ol>
<li>child<br>是指 CoordinatorLayout 的直接子 View ，并且是提供这个 Behavior 的 view 。在这个例子中<br>就是指 RecycleView  了。</li>
<li>directTargetChild<br>是指 CoordinatorLayout 的直接子 View ，包含 target 的 view。也就是说，可能是初始引起嵌套<br>滚动的 View 的父 View 。</li>
<li>target<br>是指 CoordinatorLayout 的后代子 View，初始引起嵌套滚动的 View 。</li>
</ol>
<p>回到 NestedScrollingChild 的 startNestedScroll 方法，如果我们返回 true ，那么我们就<br>回进入到方法 ViewParentCompat.onNestedScrollAccepted(p, child, mView, axes) 。<br>根据我们上面对 ViewParentCompat 理解，这个方法最后就是调用 NestedScrollingParent 中，<br>在我们这个例子中，就是进入到 CoordinatorLayout ,那直接看 CoordinatorLayout<br>的 onNestedScrollAccepted 方法。</p>
<h3 id="CoordinatorLayout_的_onNestedScrollAccepted_方法。">CoordinatorLayout 的 onNestedScrollAccepted 方法。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScrollAccepted</span><span class="params">(View child, View target, <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">    mNestedScrollingParentHelper.onNestedScrollAccepted(child, target, nestedScrollAxes);</span><br><span class="line">    mNestedScrollingDirectChild = child;</span><br><span class="line">    mNestedScrollingTarget = target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View view = getChildAt(i);</span><br><span class="line">        <span class="keyword">final</span> LayoutParams lp = (LayoutParams) view.getLayoutParams();</span><br><span class="line">        <span class="keyword">if</span> (!lp.isNestedScrollAccepted()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Behavior viewBehavior = lp.getBehavior();</span><br><span class="line">        <span class="keyword">if</span> (viewBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">            viewBehavior.onNestedScrollAccepted(<span class="keyword">this</span>, view, child, target, nestedScrollAxes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mNestedScrollingParentHelper 记录了 nestedScrollAxes ,然后就遍历所有子 View 的<br>Behavior ，如果这个 Behavior 在先前的方法 onStartNestedScroll 中返回了 false ，就<br>不会得到接下去的执行。如果返回了 true ，就调用 Behavior 的 onNestedScrollAccepted 方法。<br>意思就是，如果一个嵌套滚动被接受了，就会调用这个方法，Behavior 默认没有做任何处理。  </p>
<h3 id="嵌套中的_Down_事件总结">嵌套中的 Down 事件总结</h3><p>在 Down 事件中，touch 事件从 NestedScrollingChild 传递到 NestedScrollingChildHelper<br>, NestedScrollingParent 等，最终会传递 Behavior ，Behavior 需要表态是否接受这个<br>嵌套滚动，如果不接受，那么这个 Behavior 就不会接受这个嵌套滚动的后面 touch 事件了。<br><strong>但是一个 Behavior 不接受嵌套滚动， 并不会阻止这个 touch 事件接下来的分发流程</strong></p>
<h2 id="嵌套中的_MOVE_事件">嵌套中的 MOVE 事件</h2><p>再回到上面的 RecycleView 的 onTouchEvent 源码部分。</p>
<h3 id="RecycleView_的_dispatchNestedPreScroll_方法">RecycleView 的 dispatchNestedPreScroll 方法</h3><p>改方法会在 RecycleView 的 onTouchEvent 方法中调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedPreScroll</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed, <span class="keyword">int</span>[] offsetInWindow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getScrollingChildHelper().dispatchNestedPreScroll(dx, dy, consumed, offsetInWindow);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="NestedScrollingChildHelper_的_dispatchNestedPreScroll_方法">NestedScrollingChildHelper 的 dispatchNestedPreScroll 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * Dispatch one step of a nested pre-scrolling operation to the current nested scrolling parent.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This is a delegate method. Call it from your &#123;<span class="doctag">@link</span> android.view.View View&#125; subclass</span><br><span class="line">     * method/&#123;<span class="doctag">@link</span> NestedScrollingChild&#125; interface method with the same signature to implement</span><br><span class="line">     * the standard policy.&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span> true if the parent consumed any of the nested scroll</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedPreScroll</span><span class="params">(<span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed, <span class="keyword">int</span>[] offsetInWindow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isNestedScrollingEnabled() &amp;&amp; mNestedScrollingParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dx != <span class="number">0</span> || dy != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> startX = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> startY = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (offsetInWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mView.getLocationInWindow(offsetInWindow);</span><br><span class="line">                    startX = offsetInWindow[<span class="number">0</span>];</span><br><span class="line">                    startY = offsetInWindow[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (consumed == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mTempNestedScrollConsumed == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mTempNestedScrollConsumed = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    consumed = mTempNestedScrollConsumed;</span><br><span class="line">                &#125;</span><br><span class="line">                consumed[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                consumed[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                ViewParentCompat.onNestedPreScroll(mNestedScrollingParent, mView, dx, dy, consumed);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (offsetInWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mView.getLocationInWindow(offsetInWindow);</span><br><span class="line">                    offsetInWindow[<span class="number">0</span>] -= startX;</span><br><span class="line">                    offsetInWindow[<span class="number">1</span>] -= startY;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> consumed[<span class="number">0</span>] != <span class="number">0</span> || consumed[<span class="number">1</span>] != <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offsetInWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">                offsetInWindow[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                offsetInWindow[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>几个形参的意思</p>
<ol>
<li>consumed<br>代表 NestedScrollingChild 在 NestedPred 过程中，被 NestedScrollingParent<br>(应该说是他的子 View 的 Behavior )消耗了的距离.</li>
<li>offsetInWindow<br>在 NestedPred 流程中， NestedScrollingChild 相对屏幕左上角，位置的更改值。有可能是<br>NestedScrollingChild 在 NestedPred 过程中， NestedScrollingParent 改变了位置，<br>从而导致 NestedScrollingChild 相对屏幕左上角的位置改变了。  </li>
</ol>
<p>再看 ViewParentCompat.onNestedPreScroll 方法。其实就是看 CoordinatorLayout<br>的 onNestedPreScroll 方法了。</p>
<h3 id="CoordinatorLayout_的_onNestedPreScroll_方法了。">CoordinatorLayout 的 onNestedPreScroll 方法了。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedPreScroll</span><span class="params">(View target, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span>[] consumed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xConsumed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> yConsumed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> accepted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View view = getChildAt(i);</span><br><span class="line">        <span class="keyword">final</span> LayoutParams lp = (LayoutParams) view.getLayoutParams();</span><br><span class="line">        <span class="keyword">if</span> (!lp.isNestedScrollAccepted()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Behavior viewBehavior = lp.getBehavior();</span><br><span class="line">        <span class="keyword">if</span> (viewBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTempIntPair[<span class="number">0</span>] = mTempIntPair[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            viewBehavior.onNestedPreScroll(<span class="keyword">this</span>, view, target, dx, dy, mTempIntPair);</span><br><span class="line"></span><br><span class="line">            xConsumed = dx &gt; <span class="number">0</span> ? Math.max(xConsumed, mTempIntPair[<span class="number">0</span>])</span><br><span class="line">                    : Math.min(xConsumed, mTempIntPair[<span class="number">0</span>]);</span><br><span class="line">            yConsumed = dy &gt; <span class="number">0</span> ? Math.max(yConsumed, mTempIntPair[<span class="number">1</span>])</span><br><span class="line">                    : Math.min(yConsumed, mTempIntPair[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">            accepted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    consumed[<span class="number">0</span>] = xConsumed;</span><br><span class="line">    consumed[<span class="number">1</span>] = yConsumed;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (accepted) &#123;</span><br><span class="line">        dispatchOnDependentViewChanged(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里可以看到，consumed 的值取所有所有 Behavior 消耗的最极端值（是区分了正负）。<br>这意味着，NestedScrollingChildHelper.dispatchNestedPreScroll 的 consumed<br>是 NestedScrollingParent 的 Behavior 消耗了的。</p>
<h3 id="再看_CoordinatorLayout_的_dispatchOnDependentViewChanged_方法">再看 CoordinatorLayout 的  dispatchOnDependentViewChanged 方法</h3> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * Dispatch any dependent view changes to the relevant &#123;<span class="doctag">@link</span> Behavior&#125; instances.</span><br><span class="line">     *</span><br><span class="line">     * Usually run as part of the pre-draw step when at least one child view has a reported</span><br><span class="line">     * dependency on another view. This allows CoordinatorLayout to account for layout</span><br><span class="line">     * changes and animations that occur outside of the normal layout pass.</span><br><span class="line">     *</span><br><span class="line">     * It can also be ran as part of the nested scrolling dispatch to ensure that any offsetting</span><br><span class="line">     * is completed within the correct coordinate window.</span><br><span class="line">     *</span><br><span class="line">     * The offsetting behavior implemented here does not store the computed offset in</span><br><span class="line">     * the LayoutParams; instead it expects that the layout process will always reconstruct</span><br><span class="line">     * the proper positioning.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> fromNestedScroll true if this is being called from one of the nested scroll methods,</span><br><span class="line">     *                         false if run as part of the pre-draw step.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispatchOnDependentViewChanged</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> fromNestedScroll)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = ViewCompat.getLayoutDirection(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = mDependencySortedChildren.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = mDependencySortedChildren.get(i);</span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Check child views before for anchor</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">final</span> View checkChild = mDependencySortedChildren.get(j);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (lp.mAnchorDirectChild == checkChild) &#123;</span><br><span class="line">                    offsetChildToAnchor(child, layoutDirection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Did it change? if not continue</span></span><br><span class="line">            <span class="keyword">final</span> Rect oldRect = mTempRect1;</span><br><span class="line">            <span class="keyword">final</span> Rect newRect = mTempRect2;</span><br><span class="line">            getLastChildRect(child, oldRect);</span><br><span class="line">            getChildRect(child, <span class="keyword">true</span>, newRect);</span><br><span class="line">            <span class="keyword">if</span> (oldRect.equals(newRect)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            recordLastChildRect(child, newRect);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Update any behavior-dependent views for the change</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; childCount; j++) &#123;</span><br><span class="line">                <span class="keyword">final</span> View checkChild = mDependencySortedChildren.get(j);</span><br><span class="line">                <span class="keyword">final</span> LayoutParams checkLp = (LayoutParams) checkChild.getLayoutParams();</span><br><span class="line">                <span class="keyword">final</span> Behavior b = checkLp.getBehavior();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (b != <span class="keyword">null</span> &amp;&amp; b.layoutDependsOn(<span class="keyword">this</span>, checkChild, child)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!fromNestedScroll &amp;&amp; checkLp.getChangedAfterNestedScroll()) &#123;</span><br><span class="line">                        <span class="comment">// If this is not from a nested scroll and we have already been changed</span></span><br><span class="line">                        <span class="comment">// from a nested scroll, skip the dispatch and reset the flag</span></span><br><span class="line">                        checkLp.resetChangedAfterNestedScroll();</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> handled = b.onDependentViewChanged(<span class="keyword">this</span>, checkChild, child);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (fromNestedScroll) &#123;</span><br><span class="line">                        <span class="comment">// If this is from a nested scroll, set the flag so that we may skip</span></span><br><span class="line">                        <span class="comment">// any resulting onPreDraw dispatch (if needed)</span></span><br><span class="line">                        checkLp.setChangedAfterNestedScroll(handled);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p> 这里可能会调用 Behavior 的2个方法<br> layoutDependsOn 和 onDependentViewChanged 方法。</p>
<h3 id="Behavior_的_layoutDependsOn_方法">Behavior 的 layoutDependsOn 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Determine whether the supplied child view has another specific sibling view as a</span><br><span class="line"> * layout dependency.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This method will be called at least once in response to a layout request. If it</span><br><span class="line"> * returns true for a given child and dependency view pair, the parent CoordinatorLayout</span><br><span class="line"> * will:&lt;/p&gt;</span><br><span class="line"> * &lt;ol&gt;</span><br><span class="line"> *     &lt;li&gt;Always lay out this child after the dependent child is laid out, regardless</span><br><span class="line"> *     of child order.&lt;/li&gt;</span><br><span class="line"> *     &lt;li&gt;Call &#123;<span class="doctag">@link</span> #onDependentViewChanged&#125; when the dependency view's layout or</span><br><span class="line"> *     position changes.&lt;/li&gt;</span><br><span class="line"> * &lt;/ol&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> parent the parent view of the given child</span><br><span class="line"> * <span class="doctag">@param</span> child the child view to test</span><br><span class="line"> * <span class="doctag">@param</span> dependency the proposed dependency of child</span><br><span class="line"> * <span class="doctag">@return</span> true if child's layout depends on the proposed dependency's layout,</span><br><span class="line"> *         false otherwise</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@see</span> #onDependentViewChanged(CoordinatorLayout, android.view.View, android.view.View)</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">layoutDependsOn</span><span class="params">(CoordinatorLayout parent, V child, View dependency)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>形参的含义<br> 询问 child 到底是否依赖 dependency 。如果返回 true ， CoordinatorLayout 会在<br> lay out 完 dependency 之后，不管 child 顺序，就 lay out 这个形参 child 了。</p>
<h3 id="Behavior_的_onDependentViewChanged_方法">Behavior 的 onDependentViewChanged 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Respond to a change in a child's dependent view</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This method is called whenever a dependent view changes in size or position outside</span><br><span class="line"> * of the standard layout flow. A Behavior may use this method to appropriately update</span><br><span class="line"> * the child view in response.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;A view's dependency is determined by</span><br><span class="line"> * &#123;<span class="doctag">@link</span> #layoutDependsOn(CoordinatorLayout, android.view.View, android.view.View)&#125; or</span><br><span class="line"> * if &#123;<span class="doctag">@code</span> child&#125; has set another view as it's anchor.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Note that if a Behavior changes the layout of a child via this method, it should</span><br><span class="line"> * also be able to reconstruct the correct position in</span><br><span class="line"> * &#123;<span class="doctag">@link</span> #onLayoutChild(CoordinatorLayout, android.view.View, int) onLayoutChild&#125;.</span><br><span class="line"> * &lt;code&gt;onDependentViewChanged&lt;/code&gt; will not be called during normal layout since</span><br><span class="line"> * the layout of each child view will always happen in dependency order.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;If the Behavior changes the child view's size or position, it should return true.</span><br><span class="line"> * The default implementation returns false.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> parent the parent view of the given child</span><br><span class="line"> * <span class="doctag">@param</span> child the child view to manipulate</span><br><span class="line"> * <span class="doctag">@param</span> dependency the dependent view that changed</span><br><span class="line"> * <span class="doctag">@return</span> true if the Behavior changed the child view's size or position, false otherwise</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onDependentViewChanged</span><span class="params">(CoordinatorLayout parent, V child, View dependency)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每当 dependency 改变了位置或者大小的时候，都会触发此方法，这个方法是一个恰当的时机去改变<br>形参中的 child view 。如果在这个方法里面改变了 child 的位置或者大小，必须可以在<br>CoordinatorLayout 的 onLayoutChild 中可以复原。<strong>undo 意味着，改变 left top 没效咯？</strong><br><strong>mark</strong><br>在 Behavior 的方法 onLayoutChild 注解中可以看到，实现了 onDependentViewChanged<br>，那么也应该实现 onLayoutChild 方法。<br>如果改变了 child ，该方法就应该返回  true 。</p>
<h3 id="嵌套的_Move_事件中的_NestedPre_过程小结">嵌套的 Move 事件中的 NestedPre 过程小结</h3><p>由 NestedScrollingChild.dispatchNestedPreScroll 发起，最后给到<br>NestedScrollingParent 的 Behavior 来消费。  </p>
<ol>
<li>需要注意的是，在 NestedScrollingChild 中，需要对 Behavior 消费的距离，<br>以及因为 NestedScrollingParent 改变位置，导致 NestedScrollingChild<br>相对屏幕左上角坐标的改变，做相应的调整。  </li>
<li>layoutDependsOn 返回 true 的话，会接着调用 onDependentViewChanged ，此方法<br>是一个比较恰当的时机去改变 child ，但是需要注意需要保证在 CoordinatorLayout  的<br>onLayoutChild 方法中可以复原。</li>
</ol>
<h3 id="再回到_RecycleView_的_onTouchEvent_和_scrollByInternal_方法">再回到 RecycleView 的 onTouchEvent 和 scrollByInternal 方法</h3><p>可以看到调用了 RecycleView 的 scrollByInternal 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * Does not perform bounds checking. Used by internal methods that have already validated input.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * It also reports any unused scroll request to the related EdgeEffect.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> x The amount of horizontal scroll request</span><br><span class="line">     * <span class="doctag">@param</span> y The amount of vertical scroll request</span><br><span class="line">     * <span class="doctag">@param</span> ev The originating MotionEvent, or null if not from a touch event.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span> Whether any scroll was consumed in either direction.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">scrollByInternal</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, MotionEvent ev)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> unconsumedX = <span class="number">0</span>, unconsumedY = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> consumedX = <span class="number">0</span>, consumedY = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        consumePendingUpdateOperations();</span><br><span class="line">        <span class="keyword">if</span> (mAdapter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            eatRequestLayout();</span><br><span class="line">            onEnterLayoutOrScroll();</span><br><span class="line">            TraceCompat.beginSection(TRACE_SCROLL_TAG);</span><br><span class="line">            <span class="keyword">if</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">                consumedX = mLayout.scrollHorizontallyBy(x, mRecycler, mState);</span><br><span class="line">                unconsumedX = x - consumedX;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (y != <span class="number">0</span>) &#123;</span><br><span class="line">                consumedY = mLayout.scrollVerticallyBy(y, mRecycler, mState);</span><br><span class="line">                unconsumedY = y - consumedY;</span><br><span class="line">            &#125;</span><br><span class="line">            TraceCompat.endSection();</span><br><span class="line">            repositionShadowingViews();</span><br><span class="line">            onExitLayoutOrScroll();</span><br><span class="line">            resumeRequestLayout(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!mItemDecorations.isEmpty()) &#123;</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dispatchNestedScroll(consumedX, consumedY, unconsumedX, unconsumedY, mScrollOffset)) &#123;</span><br><span class="line">            <span class="comment">// Update the last touch co-ords, taking any scroll offset into account</span></span><br><span class="line">            mLastTouchX -= mScrollOffset[<span class="number">0</span>];</span><br><span class="line">            mLastTouchY -= mScrollOffset[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (ev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ev.offsetLocation(mScrollOffset[<span class="number">0</span>], mScrollOffset[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            mNestedOffsets[<span class="number">0</span>] += mScrollOffset[<span class="number">0</span>];</span><br><span class="line">            mNestedOffsets[<span class="number">1</span>] += mScrollOffset[<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ViewCompat.getOverScrollMode(<span class="keyword">this</span>) != ViewCompat.OVER_SCROLL_NEVER) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pullGlows(ev.getX(), unconsumedX, ev.getY(), unconsumedY);</span><br><span class="line">            &#125;</span><br><span class="line">            considerReleasingGlowsOnScroll(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (consumedX != <span class="number">0</span> || consumedY != <span class="number">0</span>) &#123;</span><br><span class="line">            dispatchOnScrolled(consumedX, consumedY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!awakenScrollBars()) &#123;</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> consumedX != <span class="number">0</span> || consumedY != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>和嵌套滚动相关的，就是调用了 dispatchNestedScroll ，这个方法里面，实际就是调用了<br>NestedScrollingChild 的 dispatchNestedScroll 方法。</p>
<h3 id="NestedScrollingChild_的_dispatchNestedScroll_方法。">NestedScrollingChild 的 dispatchNestedScroll 方法。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line">     * Dispatch one step of a nested scrolling operation to the current nested scrolling parent.</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This is a delegate method. Call it from your &#123;<span class="doctag">@link</span> android.view.View View&#125; subclass</span><br><span class="line">     * method/&#123;<span class="doctag">@link</span> NestedScrollingChild&#125; interface method with the same signature to implement</span><br><span class="line">     * the standard policy.&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span> true if the parent consumed any of the nested scroll</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchNestedScroll</span><span class="params">(<span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed,</span><br><span class="line">            <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed, <span class="keyword">int</span>[] offsetInWindow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isNestedScrollingEnabled() &amp;&amp; mNestedScrollingParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dxConsumed != <span class="number">0</span> || dyConsumed != <span class="number">0</span> || dxUnconsumed != <span class="number">0</span> || dyUnconsumed != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> startX = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> startY = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (offsetInWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mView.getLocationInWindow(offsetInWindow);</span><br><span class="line">                    startX = offsetInWindow[<span class="number">0</span>];</span><br><span class="line">                    startY = offsetInWindow[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ViewParentCompat.onNestedScroll(mNestedScrollingParent, mView, dxConsumed,</span><br><span class="line">                        dyConsumed, dxUnconsumed, dyUnconsumed);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (offsetInWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mView.getLocationInWindow(offsetInWindow);</span><br><span class="line">                    offsetInWindow[<span class="number">0</span>] -= startX;</span><br><span class="line">                    offsetInWindow[<span class="number">1</span>] -= startY;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (offsetInWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No motion, no dispatch. Keep offsetInWindow up to date.</span></span><br><span class="line">                offsetInWindow[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                offsetInWindow[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里，又算了下，让 NestedScrollingParent 的位置改变，导致 NestedScrollingChild<br>相对屏幕左上角的改变。用 offsetInWindow 记录了。 NestedScrollingChild 可能需要对<br>这个做相应的处理。中间调用的 ViewParentCompat.onNestedScroll 实际就是调用的<br>CoordinatorLayout 的 onNestedScroll</p>
<h3 id="CoordinatorLayout_的_onNestedScroll">CoordinatorLayout 的 onNestedScroll</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(View target, <span class="keyword">int</span> dxConsumed, <span class="keyword">int</span> dyConsumed,</span><br><span class="line">            <span class="keyword">int</span> dxUnconsumed, <span class="keyword">int</span> dyUnconsumed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childCount = getChildCount();</span><br><span class="line">        <span class="keyword">boolean</span> accepted = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View view = getChildAt(i);</span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) view.getLayoutParams();</span><br><span class="line">            <span class="keyword">if</span> (!lp.isNestedScrollAccepted()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Behavior viewBehavior = lp.getBehavior();</span><br><span class="line">            <span class="keyword">if</span> (viewBehavior != <span class="keyword">null</span>) &#123;</span><br><span class="line">                viewBehavior.onNestedScroll(<span class="keyword">this</span>, view, target, dxConsumed, dyConsumed,</span><br><span class="line">                        dxUnconsumed, dyUnconsumed);</span><br><span class="line">                accepted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (accepted) &#123;</span><br><span class="line">            dispatchOnDependentViewChanged(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其实都是给 Behavior 来处理了。</p>
<h3 id="嵌套滚动中_MOVE_事件整体小结">嵌套滚动中 MOVE 事件整体小结</h3><p>在 NestedPre 中，NestedScrollingChild 告诉 NestedScrollingParent 有多少滚动距离，<br>NestedScrollingParent 把滚动都给 Behavior 的 onNestedPreScroll 来处理，消费了多少，<br>需要记录下来，并告诉 NestedScrollingParent .这个 NestedScrollingParent 的 Behavior<br>消耗了多少，告诉 NestedScrollingChild 使用的方式是， NestedScrollingChild 传递<br>一个引用给 NestedScrollingParent ，NestedScrollingParent 再修改这个引用指向的对象<br>部分的属性.  </p>
<p>在 Nested 中，NestedScrollingChild 自己消费一部分，告诉 NestedScrollingParent<br>自己消费了多少，没有消费的还有多少，NestedScrollingParent 再全部告诉 Behavior 。  </p>
<p><strong>标准的做法就是</strong></p>
<ul>
<li>自己先不消耗滚动距离，让 NestedScrollingParent 的 onNestedPreScroll<br>方法优先消费滚动距离。然后 中，NestedScrollingChild 记录一下这个过程中消费的距离。</li>
<li>中，NestedScrollingChild 自己消耗一下滚动距离.</li>
<li>然后 中，NestedScrollingChild 把已经消费了的，和未消费的，给到 NestedScrollingParent<br>的方法 onNestedScroll 。</li>
</ul>
<h2 id="嵌套中的_UP_事件">嵌套中的 UP 事件</h2><p>这个就比较简单了，就是调用 NestedScrollingChild 的 stopNestedScroll ，接着<br>NestedScrollingChildHelper  的 stopNestedScroll ，最后就是<br>NestedScrollingParent 的 Behavior 的 stopNestedScroll 了。</p>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



        </div>

        


        

      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="aheadlcx" itemprop="image"/>
          <p class="site-author-name" itemprop="name">aheadlcx</p>
        </div>
        <p class="site-description motion-element" itemprop="description"></p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">28</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">3</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">15</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">aheadlcx</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
    
    

  


  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
<script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

<script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script>


  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  

  <script type="text/javascript" src="/js/bootstrap.js"></script>

  
  

  
  

</body>
</html>
